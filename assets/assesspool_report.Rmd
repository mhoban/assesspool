---
title: assessPool analysis
output:
  html_document:
    css: "https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css"
    toc: true               # table of contents
    toc_float: true         # float the table of contents to the left of the main document content
    toc_depth: 4            # header levels 1,2,3
    theme: default
    number_sections: false  # add section numbering to headers
    df_print: paged         # tables are printed as an html table with support for pagination over rows and columns
    highlight: pygments
    pdf_document: true
  pdf_document:
    toc: yes
date: "`r Sys.Date()`"
params:
  nf: null
  debug: false
  project: null
  filter: null
  final_filter: null
  fst: null
  fisher: null
  tz: null
---
```{css, echo=FALSE}
.sliderbar {
  position: fixed;
  bottom: 40%;
  margin-left: 0%;
  padding: 10px;
}
.ui-slider-wrapper {
  width: 95%
}
```
<!--
TODO: generate all figures and json in one spot so
we're not doing multiple large data-access processes
-->

<script>
// update any visible figures that were set to a different coverage cutoff
function update_figures(parent,value) {
  $(parent).find('.fig-container:visible').each(function() {
    if ($(this).data('cutoff') != value) {
      const fig_id = $(this).data('fig');
      const json_prefix = $(this).data('json-prefix');
      const json = $(`#${json_prefix}-${value}`).text();
      var fig = $(`#${fig_id}`);

      Plotly.react(fig.get(0),JSON.parse(json));
      $(this).data('cutoff',value);
    }
  });
}

// setup
$(function() {
  // add our coverage slider to the sidebar
  // and activate it as a labeled slider
  $("#TOC2").detach().insertAfter("#TOC").show();
  $("#coverage-slider").labeledslider({
    min: `r params$nf$min_coverage_cutoff`,
    max: `r params$nf$max_coverage_cutoff`,
    step: `r params$nf$coverage_cutoff_step`,
    tickInterval: `r params$nf$coverage_cutoff_step`,
    slide: function (e,ui) {
      $('.coverage-label').html(`Coverage cutoff: &#x2265;${ui.value}`)
      update_figures(document,ui.value);
    }
  });

  // respond to tab change events
  // this is to update figures that were off-screen
  // when the coverage slider was moved
  $(document).on('shown.bs.tab', function (e) {
    var target = $(e.target.ariaControlsElements);
    var val = $("#coverage-slider").labeledslider('value');
    update_figures(target,val);
  });

});
</script>

<!-- coverage slider -->
<div id="TOC2" class="sliderbar tocify" style="display: none">
  <label id="coverage-label" class="coverage-label" for="coverage-slider">Coverage cutoff: &#x2265;`r params$nf$min_coverage_cutoff`</label>
  <div id="coverage-slider"></div>
</div>
<!-- end coverage slider -->

<!-- css for labeled slider -->
<style>
/*! Ben's jQuery UI Extensions - v1.1.1 - 2014-03-30
* https://github.com/bseth99/jquery-ui-extensions
* Copyright 2014 Ben Olson; Licensed MIT */

.ui-slider-wrapper{position:relative}.ui-slider-wrapper .ui-slider-horizontal{width:100%}.ui-slider-labels{position:absolute;border:1px solid transparent}.ui-slider-label-ticks{border:1px solid transparent;position:absolute;white-space:nowrap}.ui-slider-label-ticks span{font-size:.9em;min-width:1.2em}.ui-slider-wrapper.horizontal{height:4.5em}.horizontal .ui-slider-labels{left:0;right:0;top:.7em}.horizontal .ui-slider-label-ticks{width:1.2em;height:.8em;text-align:center;border-left:1px solid #999}.horizontal .ui-slider-label-ticks span{position:relative;display:inline-block;margin-left:-1.2em;top:.8em}.ui-slider-wrapper.vertical{width:4.5em}.vertical .ui-slider-labels{top:1px;bottom:0;left:.7em}.vertical .ui-slider-label-ticks{height:1.2em;width:.8em;border-bottom:1px solid #999}.vertical .ui-slider-label-ticks span{position:relative;display:inline-block;margin-left:1em;top:.6em}

.coverage-slider {
  width: 40%;
}
</style>
<!-- js for labeled slider -->
<script>
(function(t){t.widget("ui.labeledslider",t.ui.slider,{version:"1.1.1",options:{tickInterval:0,tweenLabels:!0,tickLabels:null,tickArray:[]},uiSlider:null,tickInterval:0,tweenLabels:!0,_create:function(){this._detectOrientation(),this.uiSlider=this.element.wrap('<div class="ui-slider-wrapper ui-widget"></div>').before('<div class="ui-slider-labels">').parent().addClass(this.orientation).css("font-size",this.element.css("font-size")),this._super(),this.element.removeClass("ui-widget"),this._alignWithStep(),"horizontal"==this.orientation?this.uiSlider.width(this.element.css("width")):this.uiSlider.height(this.element.css("height")),this._drawLabels()},_drawLabels:function(){var i,e=this.options.tickLabels||{},n=this.uiSlider.children(".ui-slider-labels"),s="horizontal"==this.orientation?"left":"bottom",o=this.options.min,a=this.options.max,r=this.tickInterval,u=a-o,l=this.options.tickArray,h=l.length>0,p=0;for(n.html("");u>=p;p++)(!h&&0==p%r||h&&l.indexOf(p+o)>-1)&&(i=e[p+o]?e[p+o]:this.options.tweenLabels?p+o:"",t("<div>").addClass("ui-slider-label-ticks").css(s,Math.round(1e4*(p/u))/100+"%").html("<span>"+i+"</span>").appendTo(n))},_setOption:function(t,i){switch(this._super(t,i),t){case"tickInterval":case"tickLabels":case"tickArray":case"min":case"max":case"step":this._alignWithStep(),this._drawLabels();break;case"orientation":this.element.removeClass("horizontal vertical").addClass(this.orientation),this._drawLabels()}},_alignWithStep:function(){this.tickInterval=this.options.tickInterval<this.options.step?this.options.step:this.options.tickInterval},_destroy:function(){this._super(),this.uiSlider.replaceWith(this.element)},widget:function(){return this.uiSlider}})})(jQuery);
</script>

```{r setup, echo=FALSE, include=FALSE}
# when  run in a container, there are
# weird issues with the timezone and lubridate
# may spit out some errors. setting this fixes that
if (!is.null(params$tz)) {
  Sys.setenv(TZ=params$tz)
}

# load libraries
library(tidyr)
library(data.table)
library(knitr)
library(plotly)
library(DT)
library(stringr)
library(purrr)
library(paletteer)
library(htmltools)

if (params$debug) {
  options(show.error.locations = TRUE)
}

# set some global options
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
```

```{r init, include=FALSE}
# Load the datatables js
datatable(
  matrix(), extensions="Buttons"
)

# load the plotly js
plot_ly()

# geometric mean function
gm_mean = function(x, na.rm=TRUE, zero.propagate = FALSE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(zero.propagate){
    if(any(x == 0, na.rm = TRUE)){
      return(0)
    }
    exp(mean(log(x), na.rm = na.rm))
  } else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
  }
}

# get a sequence of coverage cutoffs from input parameters
cutoffs <- seq(params$nf$min_coverage_cutoff,params$nf$max_coverage_cutoff,params$nf$coverage_cutoff_step)

# load pool data
# start with fst
show_fst <- !is.null(params$fst)
if (show_fst) {
  pool_data <- fread(params$fst)
  pool_data[,pair := paste0(pop1," - ",pop2)]
  setorder(pool_data,method,chrom,pos)
} else {
  pool_data <- FALSE
}

fisher_data <- NULL

# load fisher data if applicable
show_fisher <- !is.null(params$fisher)
if (show_fisher) {
  fisher_data <- fread(params$fisher)
  fisher_data[,c(names(fisher_data)[!names(fisher_data) %in% c('chrom','pos','pop1','pop2','avg_min_cov','fisher','method')]) := NULL]
  setnames(fisher_data,'fisher','log_fisher')
  setcolorder(fisher_data,c('chrom','pos','pop1','pop2','avg_min_cov','log_fisher','method'))
  setorder(fisher_data,method,chrom,pos)
}

# whether to show VCF filtering
show_filter <- params$nf$visualize_filters & !is.null(params$filter)
if (show_filter) {
  filters <- fread(params$filter,col.names = c('filter','count'))
} else {
  filters <- NULL
}

# whether to show cumulative filtering
show_final_filter <- params$nf$visualize_filters & !is.null(params$final_filter)
if (show_final_filter) {
  final_filters <- fread(params$final_filter,col.names = c('filter','count'))
} else {
  final_filters <- NULL
}

# whether to show any filtering at all
any_filter <- show_filter | show_final_filter

# used for tab selection
pools_shared <- c('All SNPs'=FALSE,'Shared loci (all pools)'=TRUE)

```

# Abstract

This report summarizes the output of population genetic analyses of a pool-seq RAD library.


```{r filtering, results='asis', eval=any_filter}
# TODO: show filter option values on plot/table
cat("# Filtering {.tabset}\n")

# filtering tabs
filter_headers <- c(
  "## Stepwise filtering reuslts",
  "## Cumulative filtering results"
)
# notes to display in filter tabs
filter_notes <- c(
  'Note: filtering results displayed are independent, not cumulative.',
  'Cumulative filter results<br>(Note: filtered SNP count may differ from SNP counts associated with F<sub>st</sub> calculations).'
)

# list of filter data to use in the loop below
report_data <- list(filters,final_filters)

# walk through different filter tabs
c(show_filter,show_final_filter) %>%
  iwalk(\(show_report,i) {
    if (show_report) {
      # show tab header
      cat(filter_headers[i],"\n\n")

      # get relevant filtering data
      filter_data <- report_data[[i]][order(-count)]

      # show some header info and notes
      print(
        tagList(
          h5('SNPs remaining after each filtering step.'),
          h5(tags$small(HTML(filter_notes[i])))
        )
      )

      # rearrange filter data a bit
      # make sure 'Unfiltered' is in bold and comes first
      filter_data[,filter := replace(filter,which(filter == "before"),"<b>Unfiltered</b>")]
      filter_data[,filter := replace(filter,which(filter == "cumulative"),"All filters")]
      filter_data[,filter := forcats::fct_reorder(filter,-count)]
      filter_data[,filter := forcats::fct_relevel(filter,"<b>Unfiltered</b>")]
      filter_data[,filtered := count[filter == "<b>Unfiltered</b>"] - count]
      filter_data[,filtered := ifelse(filter == "<b>Unfiltered</b>",count,filtered)]
      filter_data[,changed := filtered > 0]

      # figure out which options did nothing
      changed <- filter_data[changed == TRUE]
      unchanged <- as.character(filter_data[changed == FALSE]$filter)
      unchanged <- str_flatten_comma(unchanged)
      # show options that didn't do anything
      if (unchanged != "") {
        print(h5(tags$small(HTML(str_glue(
          "Filter options with no effect: {unchanged}."
        )))))
      }

      # fixed-width font for tooltip
      font <- list(
        family = "Courier New",
        size = 14
      )

      # quick formatting function
      num <- scales::comma
      # tooltip template
      t_fmt <- '<b>Before filtering: {num(count[filter == "<b>Unfiltered</b>"])} SNPs<br>After filtering:  {num(count)} SNPs</b>'

      # make the bar chart
      # we use ggplot because it's better at doing continuous color scales
      # for bar plots, then convert it to a plotly plot after the fact
      fig <- ggplot(changed) +
        geom_bar(aes(x=filter,y=count,fill=count,text=str_glue(t_fmt)),stat="identity") +
        scale_fill_paletteer_c("grDevices::Turku",direction = -1,name="SNPs remaining",labels=scales::comma) +
        scale_y_continuous(labels=scales::comma) +
        theme_bw() +
        theme(axis.text.x = element_text(angle = -30, hjust=-0.1),
              axis.title.x = element_text(margin = margin(t = -20)),
              plot.title = element_text(hjust = 0.5),
              plot.margin = unit(c(0.2,0.2,0.2,0.2), "cm"))
      # plotly-ize it and do a little configuration
      fig <- fig %>%
        ggplotly(tooltip="text") %>%
        config(displayModeBar = FALSE) %>%
        layout(
          xaxis = list(title = "Filter option", fixedrange = TRUE),
          yaxis = list(title = "SNPs remaining", fixedrange = TRUE)
        )  %>%
        style(hoverlabel = list(font = font))
      print(tagList(fig))
    }
  })
```

```{r summaries, summaries, results='asis', eval=show_fst}
cat("# High-level summaries {.tabset}\n\n")

# walk through data by method
nothing <- pool_data[,{
  # output tab header
  fst_data <- .SD
  cat(str_glue("## {method} {{.tabset}}\n\n"))

  # walk through whether or not we're looking only at snps shared across all pools
  pools_shared %>%
    iwalk(\(shared,hdr) {
      # output tab header
      cat(str_glue("### {hdr} {{.tabset}}\n\n"))

      # filter data for all pools if necessary
      if (shared) {
        fst_data <- fst_data[ fst_data[, .I[all( unique(c(levels(fst_data$pop1),levels(pop2))) %in% c(pop1,pop2) )], by=c('chrom','pos')]$V1 ]
        setorder(fst_data,chrom,pos,pop1,pop2)
      }

      # repeatedly filter the dataset for different coverage levels
      # and bind those together into a new dataset
      fst_cov <- cutoffs %>%
        map(\(cov) {
          fst_data[avg_min_cov >= cov][,cutoff := cov]
        }) %>%
        # and bind resulting subsets together into a superset
        rbindlist()

      fst_cov <- fst_cov[,{
        fst_sd <- sd(fst)
        fst_se <- fst_sd / sqrt(.N)
        n_snps <- uniqueN(.SD[,.(chrom,pos)],na.rm=TRUE)
        n_contigs <- uniqueN(.SD$chrom,na.rm=TRUE)
        fst_mean <- mean(fst)
        .(
          fst_sd = fst_sd,                 
          fst = fst_mean,
          fst_se = fst_se,
          cov = mean(avg_min_cov),
          snps = n_snps, # snp count
          contigs = n_contigs,
          snps_per_contig = n_snps / n_contigs,
          ci_lower= fst_mean - qt(0.975, .N -1) * fst_se,
          ci_upper= fst_mean + qt(0.975, .N -1) * fst_se
        )
      },by=cutoff]
      setorder(fst_cov,cutoff)
      setcolorder(fst_cov,c('cutoff','fst','fst_sd','fst_se','cov','snps','snps_per_contig','ci_lower','ci_upper'))
      setnames( fst_cov,
        c('cutoff','fst','fst_sd','fst_se','cov','snps','contigs','snps_per_contig','ci_lower','ci_upper'),
        c('Coverage cutoff', 'Mean F<sub>st</sub>', 'F<sub>st</sub> (SD)', 'F<sub>st</sub> (SEM)',
          'Mean coverage', 'SNPs', 'Contigs', 'SNPs per contig', 'CI (lower)', 'CI (upper)')
      )

      # show plot tab
      cat(str_glue("#### Plot\n\n"))

      print(h5("Global summary statistics by coverage cutoff"))

      # create interactive plot and add traces
      fig <- fst_cov %>%
        plot_ly() %>%
        add_trace(
          y = ~ `Mean F<sub>st</sub>`,
          x = ~`Coverage cutoff`,
          name = "Mean F<sub>st</sub>",
          visible = T,
          mode = "lines+markers",
          type = "scatter",
          error_y = ~list(
            type='data',
            array = `F<sub>st</sub> (SD)`
          )
        ) %>%
        add_trace(
          y = ~SNPs,
          x = ~`Coverage cutoff`,
          name = "SNPs",
          mode = "lines+markers",
          type = "scatter",
          visible=F
        ) %>%
        add_trace(
          y = ~`SNPs per contig`,
          x = ~`Coverage cutoff`,
          name = "Mean SNPs per contig",
          visible = F,
          mode = "lines+markers",
          type = "scatter"
        ) %>%
        add_trace(
          y = ~Contigs,
          x = ~`Coverage cutoff`,
          name = "Contigs",
          visible = F,
          mode = "lines+markers",
          type = "scatter"
        )

      # configure button layout and behavior
      button_layout <- list(
        type = "buttons",
        direction = "right",
        xanchor = 'center',
        yanchor = "top",
        pad = list('r' = 0, 't' = 10, 'b' = 10),
        x = 0.5,
        y = 1.27,
        buttons = list(
          list(
            method = "update",
            args = list(
              list(
                visible = list(
                  T, F, F, F
                )
              ),
              list(
                yaxis = list(title = "Mean F<sub>st</sub>")
              )
            ),
            label = "F<sub>st</sub>"
          ),
          list(
            method = "update",
            args = list(
              list(
                visible = list(
                  F, T, F, F
                )
              ),
              list(yaxis = list(title = "SNPs")
              )
            ),
            label = "SNPs"
          ),
          list(
            method = "update",
            args = list(
              list(
                visible = list(
                  F, F, T, F
                )
              ),
              list(
                yaxis = list(title = "Mean SNPs per contig")
              )
            ),
            label = "SNPs per contig"
          ),
          list(
            method = "update",
            args = list(
              list(
                visible = list(
                  F, F, F, T
                )
              ),
              list(
                yaxis = list(title = "Number of contigs")
              )
            ),
            label = "Contigs"
          )
        )
      )

      # configure annotation properties
      annotation <- list(
        list(
          text = "Statistic",
          x = .15,
          y = 1.22,
          xref = 'paper',
          yref = 'paper',
          showarrow = FALSE
        )
      )

      # add layout and annotation to figure
      fig <- fig %>%
        layout(
          yaxis = list(title = "Mean F<sub>st</sub>",fixedrange=TRUE),
          xaxis = list(title = "Coverage cutoff",fixedrange=TRUE),
          title = list(text=str_glue("Summary statistics by coverage cutoff - {method}"), yref= 'paper', y=1, font=list(size=12)),
          showlegend = F,
          updatemenus = list(button_layout),
          annotations = annotation
        ) %>%
        config(displayModeBar = FALSE)

      # display figure
      print(tagList(fig))

      # show data table tab
      cat(str_glue("#### Table\n\n"))
      
      # construct csv download filename
      shared <- ifelse(shared,"all","shared")
      filename <- str_glue("{method}_{shared}_summary")

      # a javascript callback that rounds numbers to the
      # nearest thousand. otherwise the table is full of stuff like 0.3412341234123412341234
      js <- DT::JS(
        "function ( data, type, row, meta ) {",
        "return type === 'display' ?",
        "'<span class=\"num\" title=\"'+data+'\">'+(Math.round((data+Number.EPSILON)*1000)/1000).toLocaleString()+'</span>' :",
        "data;",
        "}"
      )

      print(h5("Global summary statistics by coverage cutoff"))

      # output the datatable
      print(
        tagList(
          datatable(
            fst_cov,
            escape = FALSE,
            rownames = FALSE,
            filter = "none",
            autoHideNavigation = TRUE,
            extensions = 'Buttons',
            options = list(
              dom = 'tB',
              buttons = list(
                list(
                  extend='csv',
                  title=filename,
                  exportOptions = list( modifier = list(page = "all"), orthogonal = "export"
                  )
                )
              ),
              scrollX = TRUE,
              columnDefs = list(
                list(
                  targets = c(2:5,8:10)-1,
                  render = js
                )
              )
            )
          ) %>%
            formatRound(c(1,6,7),digits=0)
        )
      )
    })
},by=method]

```



```{r fst-cov-all, results='asis', eval=show_fst}
cat("# Pairwise F<sub>st</sub> by minimum coverage {.tabset}\n\n")
# walk through calculation methods
nothing <- pool_data[,{
  # output tab header
  cat(str_glue("## {method} {{.tabset}}\n\n"))
  
  fst_data <- .SD
  
  # walk through whether or not we're looking only at snps shared across all pools
  pools_shared %>%
    iwalk(\(shared,hdr) {
      # output tab header
      cat(str_glue("### {hdr} {{.tabset}}\n\n"))
      shr <- ifelse(shared,"shared","all")
      
      # filter data for all pools if necessary
      if (shared) {
        fst_data <- fst_data[ fst_data[, .I[all( unique(c(levels(fst_data$pop1),levels(pop2))) %in% c(pop1,pop2) )], by=c('chrom','pos')]$V1 ]
        setorder(fst_data,chrom,pos,pop1,pop2)
      }
      
      # calculate plot x-axis range
      # basically, get the min and max mean fst across all coverage cutoffs
      # we're doing this so all the different versions of the plot have the
      # same x-axis. (it might be a bit data intensive but worthwhile)
      xrange <- reduce(cutoffs,\(range,cutoff) {
        r <- range(fst_data[avg_min_cov >= cutoff][,.(fst = mean(fst,na.rm=TRUE)),by=.(pop1,pop2)]$fst)
        c(min(range[1],r[1]),max(range[2],r[2]))
      },.init = c(0,0) )
      xrange <- c(min(xrange[1]-abs(0.1*xrange[1]),0),min(xrange[2]+abs(0.1*xrange[2]),1))
      
      # get initial figures and output json script tags
      fst_figs <- cutoffs %>%
        reduce(\(figs,cutoff) {
          # summarize the data by comparison and cutoff level
          # precompute box plot stats because the datasets are too big
          # and pandoc runs out of memory
          fst_grp <- fst_data[avg_min_cov >= cutoff][,{
            fst_sd <- sd(fst)
            n_snps <- uniqueN(.SD[,.(chrom,pos)],na.rm=TRUE)
            n_contigs <- uniqueN(.SD$chrom,na.rm=TRUE)
            .(
              fst_sd = fst_sd,                 # std. dev. of fst
              q1 = as.numeric(quantile(fst)[2]),
              q3 = as.numeric(quantile(fst)[4]),
              lwr = boxplot.stats(fst)$stats[1],
              upr = boxplot.stats(fst)$stats[5],
              med = median(fst),
              min = min(fst),
              max = max(fst),
              fst_se = fst_sd / sqrt(.N),      # std. err. of fst
              fst = mean(fst),                  # mean fst
              cov = mean(avg_min_cov),          # mean coverage
              snps = n_snps, # snp count
              contigs = n_contigs,  # contig count
              snps_per_contig = n_snps / n_contigs         # mean snps per contig
            )
          },by=.(pop1,pop2,pair)]
          setorder(fst_grp,pair)
          
          # plot the scatterplot
          fig <- fst_grp %>%
            plot_ly(
              x = ~ fst,
              y = ~ pair,
              color = ~snps,
              # frame = ~str_glue("≥{cutoff}"),
              # hover text templates
              text = ~str_c(snps," SNPs<br>",contigs," contigs"),
              hovertemplate = "F<sub>st</sub> (%{y}): %{x}<br>%{text}",
              type = 'scatter',
              mode = 'markers',
              marker = list(size = 12)
            ) %>%
            colorbar(title = "SNPs") %>%
            layout(
              margin=list(l = 100, r = 20, b = 10, t = 30),
              yaxis = list(title="",tickangle=-35,tickfont=list(size=12)),
              xaxis = list(title="F<sub>st</sub>",tickfont=list(size=12), range=as.list(xrange)),
              title = list(text=str_glue("F<sub>st</sub> - {hdr} (coverage &#x2265;{cutoff})"), y=0.95, font=list(size=12))
            ) %>%
            config(toImageButtonOptions = list(
              format = "svg",
              width = 900,
              height = 600
            ))
          
          # output the figure to html
          if (is.null(figs$scatter_fig)) {
            # assign div id to figure
            fig_id <- str_glue("fst-fig-{method}-{shr}")
            fig$elementId <- fig_id
            
            figs$scatter_fig <- tagList(
              div(
                `data-fig`=fig_id,
                `data-json-prefix`=str_glue("scatter-json-{method}-{shr}"),
                class="fig-container",
                tagList(fig)
              )
            )
          }
          
          # get and print the json for the figure
          fig_json <- fig %>%
            plotly_json(jsonedit = FALSE) %>%
            jsonlite::minify()
          json_tag <- tags$script(
            id = str_glue("scatter-json-{method}-{shr}-{cutoff}"),
            type = 'application/json',
            HTML(fig_json)
          )
          print(json_tag)
          
          # get outlier points, limit to a subsample of 30 per pair because
          # too many makes the thing crash.
          outs <- fst_data[avg_min_cov >= cutoff][ ,{
            outliers <- boxplot.stats(fst)$out
            .( outs = sample(outliers,min(length(outliers),30)) )
          },by=.(pop1,pop2,pair)]
          
          # generate boxplot figure
          fig <- fst_grp %>%
            plot_ly(
              type = "box",
              y = ~pair,
              q1 = ~q1,
              q3 = ~q3,
              median = ~med,
              lowerfence = ~lwr,
              upperfence = ~upr
            ) %>%
            add_trace(
              data = outs,
              inherit = FALSE,
              y = ~pair,
              x = ~outs,
              type="scatter",
              mode="markers",
              frame = ~str_glue("≥{cutoff}")
            ) %>%
            layout(showlegend = FALSE) %>%
            layout(
              yaxis = list(tickangle=-35,tickfont=list(size=12),title=""),
              xaxis = list(tickfont=list(size=12),title="F<sub>st</sub>"),
              title = list(text=str_glue("F<sub>st</sub> distribution - {hdr} (coverage &#x2265;{cutoff})"), y=0.95, font=list(size=12))
            ) %>%
            config(toImageButtonOptions = list(
              format = "svg",
              width = 900,
              height = 600
            ))
          
          # save figure for output
          if (is.null(figs$box_fig)) {
            fig_id <- str_glue("box-fig-{method}-{shr}")
            fig$elementId <- fig_id
            figs$box_fig <- tagList(
              div(
                `data-fig`=fig_id,
                `data-json-prefix`=str_glue("box-json-{method}-{shr}"),
                class="fig-container",
                tagList(fig)
              )
            )
          }
          
          # get/print figure json
          fig_json <- fig %>%
            plotly_json(jsonedit = FALSE) %>%
            jsonlite::minify()
          json_tag <- tags$script(
            id = str_glue("box-json-{method}-{shr}-{cutoff}"),
            type = 'application/json',
            HTML(fig_json)
          )
          print(json_tag)
          return(figs)
        },.init = list(scatter_fig = NULL, box_fig = NULL))
      
      # show scatter plot tab
      cat("#### Scatter plot (means)\n\n")
      
      print(fst_figs$scatter_fig)
      
      # show box plot tab
      cat("#### Box plot (distributions)\n\n")
      print(h5(tags$small(HTML(
        "Note: subsampled to 30 outliers per pair."
      ))))
      
      print(fst_figs$box_fig)
      
    })
},by=method]

```

```{r heatmaps, results='asis', eval=show_fst}
cat("# Summary statistic heatmaps {.tabset}\n\n")


# configure variable pairs for heatmap plots
var_pairs <- list(
  list(
    name="fst",
    title="F<sub>st</sub> (±SD)",
    description="Lower triangle: mean pairwise F<sub>st</sub><br>Upper triangle: standard deviation of F<sub>st</sub>",
    pairs=list(c("pop1","pop2","fst","viridis::mako",".3f","darkgrey"), c("pop2","pop1","fst_sd","viridis::inferno",".2f","darkgrey"))
  ),
  list(
    name="snps",
    title="SNPs / SNPs per contig",
    description="Lower triangle: pairwise shared SNPs contributing to F<sub>st</sub> calculation<br>Upper triangle: average shared SNPs per contig",
    pairs=list(c("pop1","pop2","snps","scico::tokyo","d","darkgrey"), c("pop2","pop1","snps_per_contig","viridis::rocket",".2f","darkgrey"))
  ),
  list(
    name="cov",
    title="Mean coverage (±SD)",
    description="Lower triangle: mean pairwise coverage<br>Upper triangle: pairwise coverage standard deviation",
    pairs=list(c("pop1","pop2","cov","viridis::cividis",".2f","darkgrey"), c("pop2","pop1","cov_sd","viridis::plasma",".2f","darkgrey"))
  ),
  list(
    name="contigs",
    title="Contigs",
    description="Pairwise shared contigs",
    pairs=list(c("pop1","pop2","contigs","scico::batlowW","d","darkgrey"), rep(NA,4))
  )
)

# map variable names to display names
value_map <- c(
  fst = "Mean F<sub>st</sub>",
  fst_sd = "F<sub>st</sub> (SD)",
  fst_se = "F<sub>st</sub> (SEM)",
  snps = "SNPs",
  cov = "Mean coverage",
  cov_sd = "Coverage (SD)",
  cov_se = "Coverage (SEM)",
  snps_per_contig = "SNPs per contig",
  contigs = "Contigs"
)

# generate a colorscale that plotly will understand from a named palette in paletteer
# increase n to increase the "smoothness" of the color scale
# na is the "missing" color, min is the dummy range used for the missing color
cscale <- function(pal,n=10,na="darkgrey",min=0.00001) {
  s <- paletteer_c(pal,n+1) %>%
    imap(\(col,i) {
      list((i-1)/n,col)
    })
  if (!is.na(na)) {
    s[[1]][[1]] <- min
    s <- c(list(list(0,na), list(min,na)),s)
  }
  s
}

# replace "NA" (not NA) in a string vector
fix_na <- function(x,na="n/a") replace(x,which(x == "NA"),na)

# walk through calculation methods
nothing <- pool_data[,{
  # show tab header
  fst_data <- .SD
  cat(str_glue("## {method} {{.tabset}}\n\n"))
  
  # walk through shared status
  pools_shared %>%
    iwalk(\(shared,hdr) {
      # show tab header
      cat(str_glue("### {hdr} {{.tabset}}\n\n"))
      shr <- ifelse(shared,"shared","all")
      
      # filter data for all pools if necessary
      if (shared) {
        fst_data <- fst_data[ fst_data[, .I[all( unique(c(levels(fst_data$pop1),levels(pop2))) %in% c(pop1,pop2) )], by=c('chrom','pos')]$V1 ]
        setorder(fst_data,chrom,pos,pop1,pop2)
      }
      
      # walk through variable pairs
      var_pairs %>%
        walk(\(trace_vars) {
          # show yet another tab header
          cat(str_glue("#### {trace_vars$title}\n\n"))
          
          print(h5(HTML(trace_vars$description)))
          print(h5(tags$small(HTML(
            "Note: Grey cells indicate missing data."
          ))))
          
          # generate figure and output
          # all necessary figure json
          heatmap_fig <- cutoffs %>%
            reduce(\(plot_fig,cutoff) {
              # summarize by pair and cutoff value
              fst_grp <- fst_data[avg_min_cov >= cutoff][,{
                fst_sd <- sd(fst,na.rm=TRUE)
                cov_sd <- sd(avg_min_cov,na.rm=TRUE)
                n_snps <- uniqueN(.SD[,.(chrom,pos)],na.rm=TRUE)
                n_contigs <- uniqueN(.SD$chrom,na.rm=TRUE)
                .(
                  fst_sd = fst_sd,                 # std. dev. of fst
                  fst_se = fst_sd / sqrt(.N),      # std. err. of fst
                  fst = mean(fst,na.rm=TRUE),                  # mean fst
                  cov = mean(avg_min_cov),          # mean coverage
                  cov_sd = cov_sd,
                  cov_se = cov_sd / sqrt(.N),
                  snps = n_snps, # snp count
                  contigs = n_contigs,  # contig count
                  snps_per_contig = n_snps / n_contigs         # mean snps per contig
                )
              },by=.(pop1,pop2)]
              fst_grp[,cutoff := cutoff]
              
              # all this next bit is so that the heatmaps look good
              # with all relevant rows of both the upper and lower triangles
              
              # get all possible pool names
              all_pops <- sort(union(unique(fst_grp$pop1),unique(fst_grp$pop2)))
              
              # create a tibble of all possible combinations (sorted)
              full_table <- all_pops %>%
                combn(2) %>%
                apply(MARGIN = 2,FUN=\(x) sort(x)) %>%
                t() %>%
                as.data.table()
              setnames(full_table,c('pop1','pop2'))
              
              # convert pool names to factors with all possible levels
              # make sure pop2 has levels in reverse so the figure looks right
              # (i.e., a nice triangle)
              # we left join from the table of all combos so we have all combos, even
              # if some have missing data
              hmd <- merge(full_table,fst_grp,by = c('pop1','pop2'),all=TRUE)[order(pop1,-pop2)]
              hmd[,`:=`(
                pop1 = factor(pop1,levels=all_pops),
                pop2 = factor(pop2,levels=rev(all_pops))
              )]
              hmd[, c(paste0(names(.SD),'_na')) := lapply(.SD,is.na), .SDcols = is.numeric]
              hmd[, c(paste0(names(.SD),'_val')) := .SD, .SDcols = is.numeric ]
              setorder(hmd,pop1,-pop2)
              
              # get the factor level that would be the top row of the plot
              top_level <- last(levels(hmd$pop2))
              
              # now we make a dummy table for just that top row
              # if we don't do this, the top triangle is missing its top row
              
              # switch pop1 and pop2
              top_row <- hmd[pop1 == top_level]
              top_row[, temp := pop1 ]
              top_row[,`:=`( pop1=pop2, pop2=temp, temp=NULL )]
              
              # set all numeric values to NA
              # cols = names(top_row)[!names(top_row) %in% c('pop1','pop2')]
              # top_row[, c(cols) := NA ]
              top_row[, (names(top_row)[sapply(top_row, is.numeric)]) := lapply(.SD, \(x) NA), .SDcols = is.numeric]
              
              # bind dummy values to plot data
              # it seems to matter that we bind these
              # to the end, rather than the other way around
              hmd <- rbind(hmd,top_row)
              
              # start making the figure
              fig <- plot_ly(hoverongaps=FALSE)
              
              # finish making the figure
              fig <- trace_vars$pairs %>%
                reduce2(c(1,2),\(plot_fig,v,i) {
                  if (!all(is.na(v))) {
                    # add the trace as either the upper or lower triangle
                    # depending on whether its #1 or #2
                    col <- str_glue("{v[3]}_na")
                    hmdd <- hmd[get(col) | is.na(get(col))]
                    hmdd[,c(v[3]) := fifelse(.SD[[col]] == TRUE,0,NA) ]
                    
                    plot_fig %>%
                      {
                        if (sum(hmd[[str_glue("{v[3]}_na")]],na.rm = T) > 0 ) {
                          add_trace(
                            .,
                            type="heatmap",
                            hoverinfo = 'none',
                            data = hmdd,
                            x = ~.data[[v[1]]],
                            y = ~.data[[v[2]]],
                            z = ~.data[[v[3]]],
                            colorscale = 'Greys',
                            showscale = FALSE 
                          )
                        } else .
                      } %>%
                      add_trace(
                        type = "heatmap",
                        data = hmd, 
                        x = ~.data[[v[1]]], # x variable
                        y = ~.data[[v[2]]], # y variable
                        z = ~.data[[v[3]]], # z (color) variable
                        # this is what gets shown in the tooltip
                        customdata = ~fix_na( sprintf( str_c("%",v[5]), .data[[ str_glue("{v[3]}_val") ]] ) ),
                        colorscale = cscale(v[4],n = 10,na = NA), # color palette, based on 100 gradations
                        # style the colorbar
                        colorbar = list(
                          # show the appropriate display name
                          title=list(text=value_map[v[3]]),
                          # determine the position of the colorbar
                          # bottom if it's for the bottom triangle, top if it's for the top
                          y = ifelse(i == 1,0,1),
                          # which side of the colorbar we reckon the y-anchor from
                          yanchor = ifelse(i == 1,"bottom","top"),
                          len = 0.5,
                          lenmode = "fraction"
                        ),
                        # text template
                        text = ~str_glue("{pop1} - {pop2}"),
                        # hover text template (hide the trace name with <extra></extra>)
                        hovertemplate=str_glue("%{{text}}<br>{value_map[v[3]]}: %{{customdata}}<extra></extra>")
                      )
                  } else return(plot_fig)
                },.init = fig) %>%
                layout(
                  # name the figure axes and don't let the user zoom around
                  xaxis = list(title = "Pool 1", fixedrange = TRUE),
                  yaxis = list(title = "Pool 2", fixedrange = TRUE),
                  title = list(
                    text = str_glue("{trace_vars$title} (coverage cutoff: &#x2265;{cutoff})"),
                    font = list(
                      size = 12
                    )
                  )
                ) %>%
                # hide the mode bar
                config(displayModeBar = FALSE)
              
              # get the figure for output
              if (is.null(plot_fig)) {
                fig_id <- str_glue("heatmap-fig-{method}-{shr}-{trace_vars$name}")
                fig$elementId <- fig_id
                # we stick it in a div with class 'fig-container' so
                # they're easy to find in the DOM using jquery
                plot_fig <- tagList(
                  div(
                    `data-fig`=fig_id,
                    `data-json-prefix`=str_glue("heatmap-json-{method}-{shr}-{trace_vars$name}"),
                    class="fig-container",
                    tagList(fig)
                  )
                )
              }
              
              # get the figure json and output it
              fig_json <- fig %>%
                plotly_json(jsonedit = FALSE) %>%
                jsonlite::minify()
              # create and print script tag with figure data json
              # we use this to draw the other cutoff level figures when the slider is dragged
              json_tag <- tags$script(
                id = str_glue("heatmap-json-{method}-{shr}-{trace_vars$name}-{cutoff}"),
                type = 'application/json',
                HTML(fig_json)
              )
              print(json_tag)
              
              return(plot_fig)
            },.init = NULL)
          
          # output the heatmap figure
          print(heatmap_fig)
        })
    })
},by=method]

```


```{r fst-correlation, results='asis', eval=show_fst}
cat("# F<sub>st</sub> method correlations {.tabset}\n\n")

# get calculation methods
methods <- unique(pool_data$method)
# split the dataset into subsets by calculation method
methods %>%
  combn(2) %>%
  array_branch(2) %>%
  walk(\(methods) {
    cat(str_glue("## {methods[1]} vs {methods[2]}\n\n"))
    print(h5(tags$small(HTML("Note: Due to potentially large datasets, only a subsample of 1,000 F<sub>st</sub> values is shown here."))))
    
    # make a joined table with both methods and subsample to max 1000 rows
    corr <- merge(
      pool_data[ method == methods[1] ][sample(.N,1000),],
      pool_data[ method == methods[2] ],
      by = c('chrom','pos','pop1','pop2')
    )

    # do a linear regression
    lmm <- lm(fst.y ~ fst.x, data=corr)

    # get predicted data for the trend line
    corr[,predicted := predict(lmm,corr[,.(fst.x)])]

    # get method names
    xtitle <- methods[1]
    ytitle <- methods[2]

    # plot the figure
    fig <- corr %>%
      plot_ly() %>%
      # add 1:1 line
      add_trace(
        x = ~fst.x,
        y = ~fst.x,
        type = 'scatter',
        mode = 'lines',
        line = list(color = '#232323', width = 0.7)
      ) %>%
      # add scatter
      add_trace(
        x = ~fst.x,
        y = ~fst.y,
        type = 'scatter',
        mode = 'markers',
        marker = list(color = 'black')
      ) %>%
      # add trend line
      add_trace(
        x = ~fst.x,
        y = ~predicted,
        type = 'scatter',
        mode = 'lines',
        line = list(color = 'lightskyblue', dash="dash", width = 0.7)
      ) %>%
      layout(
        # label axes
        xaxis = list(title = str_glue("F<sub>st</sub> ({xtitle})")),
        yaxis = list(title = str_glue("F<sub>st</sub> ({ytitle})"))
      ) %>%
      # disappear the legends
      hide_guides()

    print(tagList(fig))
  })
```

```{r fisher, results='asis', eval=show_fisher}
cat("# Fisher test plots {.tabset}\n\n")
print(h5(tags$small(
  "Fisher test results are presented as static plots since these datasets can get huge, making plotly go slow or crash."
)))

nothing <- fisher_data[,{
  fishr <- .SD
  cat(str_glue("## {method}\n\n"))
  
  # TODO: fix cutoff slider for fisher plots
  # make slider for coverage cutoff
  cutoff_slider <- div(
    class="coverage-slider",
    tagList(
      tags$label(
        id=str_glue("fisher-cutoff-label-{method}"),
        `for`=str_glue("fisher-cutoff-sel-{method}"),
        str_glue('Minimum coverage: {params$nf$min_coverage_cutoff}')
      ),
      div(
        id=str_glue("fisher-cutoff-sel-{method}")
      )
    )
  )
  print(cutoff_slider)
  
  cutoff_script <- tags$script(HTML(str_glue(
    '
      $(function() {{
        $("#fisher-cutoff-sel-{method}").labeledslider({{
          min: {params$nf$min_coverage_cutoff},
          max: {params$nf$max_coverage_cutoff},
          step: {params$nf$coverage_cutoff_step},
          tickInterval: {params$nf$coverage_cutoff_step},
          change: function (e, ui) {{
            $(".fisher-plotz-{method}").hide();
            $(`#fisher-plot-{method}-${{ui.value}}`).show();
            $("#fisher-cutoff-label-{method}").text(`Minimum coverage: ${{ui.value}}`);
          }},
          slide: function (e, ui) {{
            $(".fisher-plotz-{method}").hide();
            $(`#fisher-plot-{method}-${{ui.value}}`).show();
            $("#fisher-cutoff-label-{method}").text(`Minimum coverage: ${{ui.value}}`);
          }}
        }});
     }});
    '
  )))
  print(cutoff_script)
  
  print(h6(HTML("Points above red line indicate <em>p</em> &lt; 0.05.")))
  
  figs <- cutoffs %>%
    # set_names() %>%
    map(\(cov) {
      
      # filter by coverage cutoff and get mean fisher p-value by snp
      figdata <- fishr[avg_min_cov >= cov][,.(log_fisher = mean(log_fisher)), by=.(chrom,pos)][order(chrom,pos)] 
      figdata[,snp := .I]
      
      fig <- ggplot(figdata) +
        geom_point(aes(x=snp,y=log_fisher),size=1) +
        geom_hline(yintercept = -log10(0.05), color="red") +
        theme_bw() +
        labs(x = 'SNP', y=expression(paste(-log[10]~"(p-value)")))
      
      disp <- if(cov == first(cutoffs)) "" else "display: none"
      plotTag(
        fig,
        alt=str_glue("Fisher's exast test p-values for coverage ≥{cov}"),
        width = 672,
        attribs = list(
          id = str_glue("fisher-plot-{method}-{cov}"),
          class = str_glue('fisher-plotz-{method}'),
          style = disp
        )
      )
    })
  print(div(
    id='fisher-container',
    tagList( figs )
  ))
},by=method]
```
