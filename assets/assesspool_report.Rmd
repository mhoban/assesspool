---
title: assessPool analysis
output:
  html_document:
    css: "https://code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css"
    toc: true               # table of contents
    toc_float: true         # float the table of contents to the left of the main document content
    toc_depth: 4            # header levels 1,2,3
    theme: default
    number_sections: false  # add section numbering to headers
    df_print: paged         # tables are printed as an html table with support for pagination over rows and columns
    highlight: pygments
    pdf_document: true
  pdf_document:
    toc: yes
date: "`r Sys.Date()`"
params:
  nf: null
  debug: false
  project: null
  filter: null
  final_filter: null
  fst: null
  fisher: null
  tz: null
---
<style>
/*! Ben's jQuery UI Extensions - v1.1.1 - 2014-03-30
* https://github.com/bseth99/jquery-ui-extensions
* Copyright 2014 Ben Olson; Licensed MIT */

.ui-slider-wrapper{position:relative}.ui-slider-wrapper .ui-slider-horizontal{width:100%}.ui-slider-labels{position:absolute;border:1px solid transparent}.ui-slider-label-ticks{border:1px solid transparent;position:absolute;white-space:nowrap}.ui-slider-label-ticks span{font-size:.9em;min-width:1.2em}.ui-slider-wrapper.horizontal{height:4.5em}.horizontal .ui-slider-labels{left:0;right:0;top:.7em}.horizontal .ui-slider-label-ticks{width:1.2em;height:.8em;text-align:center;border-left:1px solid #999}.horizontal .ui-slider-label-ticks span{position:relative;display:inline-block;margin-left:-1.2em;top:.8em}.ui-slider-wrapper.vertical{width:4.5em}.vertical .ui-slider-labels{top:1px;bottom:0;left:.7em}.vertical .ui-slider-label-ticks{height:1.2em;width:.8em;border-bottom:1px solid #999}.vertical .ui-slider-label-ticks span{position:relative;display:inline-block;margin-left:1em;top:.6em}

.coverage-slider {
  width: 40%;
}
</style>
<script>
(function(t){t.widget("ui.labeledslider",t.ui.slider,{version:"1.1.1",options:{tickInterval:0,tweenLabels:!0,tickLabels:null,tickArray:[]},uiSlider:null,tickInterval:0,tweenLabels:!0,_create:function(){this._detectOrientation(),this.uiSlider=this.element.wrap('<div class="ui-slider-wrapper ui-widget"></div>').before('<div class="ui-slider-labels">').parent().addClass(this.orientation).css("font-size",this.element.css("font-size")),this._super(),this.element.removeClass("ui-widget"),this._alignWithStep(),"horizontal"==this.orientation?this.uiSlider.width(this.element.css("width")):this.uiSlider.height(this.element.css("height")),this._drawLabels()},_drawLabels:function(){var i,e=this.options.tickLabels||{},n=this.uiSlider.children(".ui-slider-labels"),s="horizontal"==this.orientation?"left":"bottom",o=this.options.min,a=this.options.max,r=this.tickInterval,u=a-o,l=this.options.tickArray,h=l.length>0,p=0;for(n.html("");u>=p;p++)(!h&&0==p%r||h&&l.indexOf(p+o)>-1)&&(i=e[p+o]?e[p+o]:this.options.tweenLabels?p+o:"",t("<div>").addClass("ui-slider-label-ticks").css(s,Math.round(1e4*(p/u))/100+"%").html("<span>"+i+"</span>").appendTo(n))},_setOption:function(t,i){switch(this._super(t,i),t){case"tickInterval":case"tickLabels":case"tickArray":case"min":case"max":case"step":this._alignWithStep(),this._drawLabels();break;case"orientation":this.element.removeClass("horizontal vertical").addClass(this.orientation),this._drawLabels()}},_alignWithStep:function(){this.tickInterval=this.options.tickInterval<this.options.step?this.options.step:this.options.tickInterval},_destroy:function(){this._super(),this.uiSlider.replaceWith(this.element)},widget:function(){return this.uiSlider}})})(jQuery);
</script>
```{r setup, echo=FALSE, include=FALSE}
# when  run in a container, there are
# weird issues with the timezone and lubridate
# may spit out some errors. setting this fixes that
if (!is.null(params$tz)) {
  Sys.setenv(TZ=params$tz)
}

# load libraries
library(tidyr)
library(knitr)
library(yaml)
library(plotly)
library(DT)
library(readr)
library(dplyr)
library(stringr)
library(purrr)
library(paletteer)
library(fs)
library(htmltools)

if (params$debug) {
  options(show.error.locations = TRUE)
}

# set some global options
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
options(dplyr.summarise.inform = FALSE)
```

```{r init, include=FALSE}
# Load the datatables js
datatable(
  matrix(), extensions="Buttons"
)

# load the plotly js
plot_ly()

# plotly horizontal line
hline <- function(y = 0, color = "black") {
  list(
    type = "line",
    x0 = 0,
    x1 = 1,
    xref = "paper",
    y0 = y,
    y1 = y,
    line = list(color = color)
  )
}

# geometric mean function
gm_mean = function(x, na.rm=TRUE, zero.propagate = FALSE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(zero.propagate){
    if(any(x == 0, na.rm = TRUE)){
      return(0)
    }
    exp(mean(log(x), na.rm = na.rm))
  } else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
  }
}

# get a sequence of coverage cutoffs from input parameters
cutoffs <- seq(params$nf$report_min_coverage,params$nf$report_max_coverage,params$nf$report_coverage_step)

# load pool data
# start with fst
show_fst <- !is.null(params$fst)
if (show_fst) {
  pool_data <- read_tsv(params$fst)
} else {
  pool_data <- FALSE
}

fisher_data <- NULL

# load fisher data if applicable
show_fisher <- !is.null(params$fisher)
if (show_fisher) {
  fisher_data <- read_tsv(params$fisher) %>%
    select(chrom,pos,pop1,pop2,avg_min_cov,log_fisher=fisher,method)
}

# whether to show VCF filtering
show_filter <- params$nf$visualize_filters & !is.null(params$filter)
if (show_filter) {
  filters <- read_tsv(params$filter)
} else {
  filters <- NULL
}

show_final_filter <- params$nf$visualize_filters & !is.null(params$final_filter)
if (show_final_filter) { 
  final_filters <- read_tsv(params$final_filter)
} else {
  final_filters <- NULL
}

any_filter <- show_filter | show_final_filter

# used for tab selection
all_pools <- c('All SNPs'=FALSE,'Shared loci (all pools)'=TRUE)

# place where stuff gets saved
data_dir <- "artifacts"

# create artifacts dir
# if it already exists nobody will care
dir_create(data_dir)

# move fst file into artifacts dir
# file_move(params$fst,data_dir)
```

<!-- this section only gets processed if params$debug is TRUE -->
```{r, results='asis',  eval=params$debug}
cat("# Debug info\n")
```

```{r, eval=params$debug}
if (params$debug) {
  # print(params$meta$pools)
  cat("params\n\n")
  str(params)
}
```
<!-- end debug section -->

# Abstract

This report summarizes the output of population genetic analyses of a pool-seq RAD library.

```{r, results='asis', eval=any_filter}
# TODO: show filter option values on plot/table
cat("# Filtering {.tabset}\n")

filter_headers <- c(
  "## Stepwise filtering reuslts",
  "## Cumulative filtering results"
)
filter_notes <- c(
  'Note: filtering results displayed are independent, not cumulative.',
  'Cumulative filter results<br>(Note: filtered SNP count may differ from SNP counts associated with F<sub>st</sub> calculations).'
)

report_data <- list(filters,final_filters)

c(show_filter,show_final_filter) %>%
  iwalk(\(show_report,i) {
    if (show_report) {
      # show tab header
      cat(filter_headers[i],"\n\n")
      
      # get relevant filtering data
      filter_data <- report_data[[i]]
      
      print(
        tagList(
          h5('SNPs remaining after each filtering step.'),
          h5(tags$small(HTML(filter_notes[i])))
        )
      )
      filter_data <- filter_data %>%
        arrange(desc(count)) %>%
        mutate(
          filter = replace(filter,which(filter == "before"),"<b>Unfiltered</b>"),
          filter = replace(filter,which(filter == "cumulative"),"All filters"),
          filter = forcats::fct_reorder(filter,-count),
          filter = forcats::fct_relevel(filter,"<b>Unfiltered</b>"),
          filtered = count[filter == "<b>Unfiltered</b>"] - count,
          filtered = case_when(
            filter == "<b>Unfiltered</b>" ~ count,
            .default = filtered
          ),
          changed = filtered > 0
        ) #%>%
      # filter(filtered > 0)
      changed <- filter_data %>%
        filter(changed)
      unchanged <- filter_data %>%
        filter(!changed) %>%
        pull(filter) %>%
        as.character()
      unchanged <- str_glue("<b>{unchanged}</b>")
      unchanged <- str_c(unchanged,collapse=", ")
      if (unchanged != "") {
        print(h5(tags$small(HTML(str_glue(
          "Filter options with no effect: {unchanged}."
        )))))
      }
      
      font <- list(
        family = "Courier New",
        size = 14
      )
      label <- list( font = font )
      num <- scales::comma
      t_fmt <- '<b>Before filtering: {num(count[filter == "<b>Unfiltered</b>"])} SNPs<br>After filtering:  {num(count)} SNPs</b>'
      fig <- ggplot(changed) +
        geom_bar(aes(x=filter,y=count,fill=count,text=str_glue(t_fmt)),stat="identity") +
        scale_fill_paletteer_c("grDevices::Turku",direction = -1,name="SNPs remaining",labels=scales::comma) +
        scale_y_continuous(labels=scales::comma) +
        theme_bw() +
        theme(axis.text.x = element_text(angle = -30, hjust=-0.1),
              axis.title.x = element_text(margin = margin(t = -20)),
              plot.title = element_text(hjust = 0.5),
              plot.margin = unit(c(0.2,0.2,0.2,0.2), "cm"))
      fig <- fig %>%
        ggplotly(tooltip="text") %>%
        config(displayModeBar = FALSE) %>%
        layout(
          xaxis = list(title = "Filter option", fixedrange = TRUE),
          yaxis = list(title = "SNPs remaining", fixedrange = TRUE)
        )  %>%
        style(hoverlabel = label)
      print(tagList(fig))
    } 
  })
```

```{r, summaries, results='asis', eval=show_fst}
cat("# High-level summaries {.tabset}\n\n")

pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # walk through all_shared elements
    # (whether or not we're looking only at snps shared across all pools)
    all_pools %>%
      iwalk(\(all_shared,hdr) {
        # output tab header
        cat(str_glue("### {hdr} {{.tabset}}\n\n"))

        # filter data for all pools if necessary
        if (all_shared) {
          fst_data <- fst_data %>%
            mutate(pop1=factor(pop1),pop2=factor(pop2)) %>%
            group_by(chrom,pos) %>%
            filter( all( unique(c(levels(pop1),levels(pop2))) %in% c(pop1,pop2) ) ) %>% 
            ungroup() %>%
            arrange(chrom,pos,pop1,pop2)
        }

        # repeatedly filter the dataset for different coverage levels
        # and bind those together into a new dataset
        fst_cov <- cutoffs %>%
          map(\(cov) {
            fst_data %>%
              # filter by average minimum coverage
              filter(avg_min_cov >= cov) %>%
              # retain the cutoff level in the data
              mutate(cutoff=cov)
          }) %>%
          # and bind resulting subsets together into a superset
          list_rbind()

        # summarize the data by comparison and cutoff level
        fst_grp <- fst_cov %>%
          group_by(cutoff) %>%
          summarise(
            fst_sd = sd(fst),                 # std. dev. of fst
            fst = mean(fst),                  # mean fst
            fst_se = fst_sd / sqrt(n()),      # std. err. of fst
            cov = mean(avg_min_cov),          # mean coverage
            snps = n_distinct(chrom,pos,na.rm = TRUE),                       # snp count
            contigs = n_distinct(chrom,na.rm=TRUE),      # contig count
            snps_per_contig = snps / contigs, # mean snps per contig
            ci_lower= fst - qt(0.975, n() -1) * fst_se,
            ci_upper= fst + qt(0.975, n() -1) * fst_se
          ) %>%
          arrange(cutoff) %>%
          ungroup() %>%
          select(
            `Coverage cutoff`=cutoff,
            `Mean F<sub>st</sub>`=fst,
            `F<sub>st</sub> (SD)`=fst_sd,
            `F<sub>st</sub> (SEM)`=fst_se,
            `Mean coverage`=cov,
            SNPs=snps,
            Contigs=contigs,
            `SNPs per contig`=snps_per_contig,
            `CI (lower)`=ci_lower,
            `CI (upper)`=ci_upper
          )

        shared <- ifelse(all_shared,"all","shared")
        filename <- str_glue("{method$method}_{shared}_summary")

        # a javascript callback that rounds numbers to the 
        # nearest thousand. otherwise the table is full of stuff like 0.3412341234123412341234
        js <- DT::JS(
          "function ( data, type, row, meta ) {",
          "return type === 'display' ?",
          "'<span class=\"num\" title=\"'+data+'\">'+(Math.round((data+Number.EPSILON)*1000)/1000).toLocaleString()+'</span>' :",
          "data;",
          "}"
        )

        # show plot table
        cat(str_glue("#### Plot\n\n"))

        print(h5("Global summary statistics by coverage cutoff"))

        # create interactive plot and add traces
        fig <- fst_grp %>%
          plot_ly() %>%
          add_trace(
            y = ~ `Mean F<sub>st</sub>`,
            x = ~`Coverage cutoff`,
            name = "Mean F<sub>st</sub>",
            visible = T,
            mode = "lines+markers",
            type = "scatter",
            error_y = ~list(
              type='data',
              array = `F<sub>st</sub> (SD)`
            )
          ) %>%
          add_trace(
            y = ~SNPs,
            x = ~`Coverage cutoff`,
            name = "SNPs",
            mode = "lines+markers",
            type = "scatter",
            visible=F
          ) %>%
          add_trace(
            y = ~`SNPs per contig`,
            x = ~`Coverage cutoff`,
            name = "Mean SNPs per contig",
            visible = F,
            mode = "lines+markers",
            type = "scatter"
          ) %>%
          add_trace(
            y = ~Contigs,
            x = ~`Coverage cutoff`,
            name = "Contigs",
            visible = F,
            mode = "lines+markers",
            type = "scatter"
          )

        # configure button layout and behavior
        button_layout <- list(
          type = "buttons",
          direction = "right",
          xanchor = 'center',
          yanchor = "top",
          pad = list('r' = 0, 't' = 10, 'b' = 10),
          x = 0.5,
          y = 1.27,
          buttons = list(
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    T, F, F, F
                  )
                ),
                list(
                  yaxis = list(title = "Mean F<sub>st</sub>")
                )
              ),
              label = "F<sub>st</sub>"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, T, F, F
                  )
                ),
                list(yaxis = list(title = "SNPs")
                )
              ),
              label = "SNPs"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, F, T, F
                  )
                ),
                list(
                  yaxis = list(title = "Mean SNPs per contig")
                )
              ),
              label = "SNPs per contig"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, F, F, T
                  )
                ),
                list(
                  yaxis = list(title = "Number of contigs")
                )
              ),
              label = "Contigs"
            )
          )
        )

        # configure annotation properties
        annotation <- list(
          list(
            text = "Statistic",
            x = .15,
            y = 1.22,
            xref = 'paper',
            yref = 'paper',
            showarrow = FALSE
          )
        )

        # add layout and annotation to figure
        fig <- fig %>% layout(
          yaxis = list(title = "Mean F<sub>st</sub>",fixedrange=TRUE),
          xaxis = list(title = "Coverage cutoff",fixedrange=TRUE),
          title = list(text=str_glue("Summary statistics by coverage cutoff - {method$method}"), yref= 'paper', y=1),
          showlegend = F,
          updatemenus = list(button_layout),
          annotations = annotation
        ) %>%
          config(displayModeBar = FALSE)

        # display figure
        print(tagList(fig))

        # show data table tab
        cat(str_glue("#### Table\n\n"))

        print(h5("Global summary statistics by coverage cutoff"))

        # output the datatable
        print(
          tagList(
            datatable(
              fst_grp,
              escape = FALSE,
              rownames = FALSE,
              filter = "none",
              autoHideNavigation = TRUE,
              extensions = 'Buttons',
              options = list(
                dom = 'tB',
                buttons = list(
                  list(
                    extend='csv',
                    title=filename,
                    exportOptions = list( modifier = list(page = "all"), orthogonal = "export"
                    )
                  )
                ),
                scrollX = TRUE,
                columnDefs = list(
                  list(
                    targets = c(2:5,8:10)-1,
                    render = js
                  )
                )
              )
            ) %>%
              formatRound(c(1,6,7),digits=0)
          )
        )
      })
  })
```



```{r fst-cov-all, results='asis', eval=show_fst}
cat("# Pairwise F<sub>st</sub> by minimum coverage {.tabset}\n\n")
# TODO: tie slider position in this plot to heatmap coverage slider
# (corresponding to method, shared snps, etc.)

# walk through calculation methods
pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # walk through all_shared elements
    # (whether or not we're looking only at snps shared across all pools)
    all_pools %>%
      iwalk(\(all_shared,hdr) {
        # output tab header
        cat(str_glue("### {hdr} {{.tabset}}\n\n"))

        # filter data for all pools if necessary
        if (all_shared) {
          # get all unique pool names
          all_pools <- sort(
            union(
              unique(fst_data$pop1),
              unique(fst_data$pop2)
            )
          )

          # group data by snp (chrom/pos) and retain
          # snps where all populations are represented in comparisons
          # (either side)
          fst_data <- fst_data %>%
            group_by(chrom,pos) %>%
            filter(all(all_pools %in% unique(c(unique(pop1),unique(pop2))))) %>%
            ungroup()
        }



        # repeatedly filter the dataset for different coverage levels
        # and bind those together into a new dataset
        fst_cov <- cutoffs %>%
          map(\(cov) {
            fst_data %>%
              # filter by average minimum coverage
              filter(avg_min_cov >= cov) %>%
              # retain the cutoff level in the data
              mutate(cutoff=cov)
          }) %>%
          # and bind resulting subsets together into a superset
          list_rbind() %>%
          # create a text representation of the comparison
          mutate(pair = str_glue("{pop1} - {pop2}"))

        # summarize the data by comparison and cutoff level
        # precompute box plot stats because the datasets are too big
        # and pandoc runs out of memory
        fst_grp <- fst_cov %>%
          group_by(pop1,pop2,pair,cutoff) %>%
          summarise(
            fst_sd = sd(fst),                 # std. dev. of fst
            q1 = as.numeric(quantile(fst)[2]),
            q3 = as.numeric(quantile(fst)[4]),
            lwr = boxplot.stats(fst)$stats[1],
            upr = boxplot.stats(fst)$stats[5],
            med = median(fst),
            min = min(fst),
            max = max(fst),
            fst = mean(fst),                  # mean fst
            fst_se = fst_sd / sqrt(n()),      # std. err. of fst
            cov = mean(avg_min_cov),          # mean coverage
            snps = n_distinct(chrom,pos,na.rm=TRUE),                       # snp count
            contigs = n_distinct(chrom,na.rm=TRUE),      # contig count
            snps_per_contig = snps / contigs  # mean snps per contig
          ) %>%
          # sort by cutoff and comparison
          arrange(cutoff,pair) %>%
          ungroup()

        # plot scatter plot header
        cat("#### Scatter plot (means)\n\n")

        # plot the scatterplot
        fig <- fst_grp %>%
          plot_ly(
            x = ~ fst,
            y = ~ pair,
            color = ~snps,
            frame = ~str_glue("≥{cutoff}"),
            # hover text templates
            text = ~str_c(snps," SNPs<br>",contigs," contigs"),
            hovertemplate = "F<sub>st</sub> (%{y}): %{x}<br>%{text}",
            type = 'scatter',
            mode = 'markers',
            marker = list(size = 12)
          ) %>%
          colorbar(title = "SNPs") %>%
          layout(
            margin=list(l = 100, r = 20, b = 10, t = 30),
            yaxis = list(title="",tickangle=-35,tickfont=list(size=12)),
            xaxis = list(title="F<sub>st</sub>",tickfont=list(size=12)),
            title = list(text=str_glue("F<sub>st</sub> - {hdr}"), y=0.95)
          ) %>%
          # customize slider and remove play button
          animation_slider(currentvalue = list(prefix = "Minimum coverage: ", font = list(color = "black"))) %>%
          animation_button(visible = FALSE)

        # assign div id to figure
        shr <- ifelse(all_shared,"shared","all")
        fig_id <- str_glue("fst-fig-{method$method}-{shr}")
        fig$elementId <- fig_id

        # output the figure to html
        print(tagList(fig))

        # TODO: slider change event
        # fig_script <- tags$script(
        #   HTML(str_glue('
        #   $(function() {{
        #     $("#{fig_id}").on("plotly_sliderchange",function(e,data) {{
        #       var cutoff = parseInt(data.slider.steps[data.slider.active].label.replaceAll(/[^0-9]+/g,""));
        #       console.log("Cutoff: " + cutoff);
        #     }})
        #   }});
        #   '))
        # )
        # print(fig_script)

        # print box plot header
        cat("#### Box plot (distributions)\n\n")

        # get outlier points
        outs <- fst_cov %>%
          group_by(pop1,pop2,pair,cutoff) %>%
          summarise(outs = boxplot.stats(fst)$out)  %>%
          ungroup()

        # generate boxplot figure
        fig <- fst_grp %>%
          plot_ly(
            type = "box",
            y = ~pair,
            q1 = ~q1,
            q3 = ~q3,
            median = ~med,
            frame = ~str_glue("≥{cutoff}"),
            lowerfence = ~lwr,
            upperfence = ~upr
          ) %>%
          add_trace(
            data = outs,
            inherit = FALSE,
            y = ~pair,
            x = ~outs,
            type="scatter",
            mode="markers",
            frame = ~str_glue("≥{cutoff}")
          ) %>%
          layout(showlegend = FALSE) %>%
          animation_slider(currentvalue = list(prefix = "Minimum coverage: ", font = list(color = "black"))) %>%
          animation_button(visible = FALSE) %>%
          layout(
            #margin=list(l = 200, r = 20, b = 80, t = 40),
            yaxis = list(tickangle=-35,tickfont=list(size=12),title=""),
            xaxis = list(tickfont=list(size=12),title="F<sub>st</sub>")
          )
        print(tagList(fig))
      })
  })

```

```{r, heatmap-setup, results='asis', eval=show_fst}
# TODO: add all snps/shared loci to heatmap plots
cat("# Summary statistic heatmaps {.tabset}\n\n")

# a list of parameters we'll use to plot each figure
# each item consists of: display name, bottom-left heatmap, and (optionally) top-right heatmap
# individual heatmap options are: x value, y value, variable name, color palette (from paletteer_c),
# number format (passed to sprintf), and missing color
var_pairs <- list(
  list(
    name="fst",
    title="F<sub>st</sub> (±SD)",
    description="Lower triangle: mean pairwise F<sub>st</sub><br>Upper triangle: standard deviation of F<sub>st</sub>",
    pairs=list(c("pop1","pop2","fst","viridis::mako",".3f","darkgrey"), c("pop2","pop1","fst_sd","viridis::inferno",".2f","darkgrey"))
  ),
  list(
    name="snps",
    title="SNPs / SNPs per contig",
    description="Lower triangle: pairwise shared SNPs contributing to F<sub>st</sub> calculation<br>Upper triangle: average shared SNPs per contig",
    pairs=list(c("pop1","pop2","snps","scico::tokyo","d","darkgrey"), c("pop2","pop1","snps_per_contig","viridis::rocket",".2f","darkgrey"))
  ),
  list(
    name="cov",
    title="Mean coverage (±SD)",
    description="Lower triangle: mean pairwise coverage<br>Upper triangle: pairwise coverage standard deviation",
    pairs=list(c("pop1","pop2","cov","viridis::cividis",".2f","darkgrey"), c("pop2","pop1","cov_sd","viridis::plasma",".2f","darkgrey"))
  ),
  list(
    name="contigs",
    title="Contigs",
    description="Pairwise shared contigs",
    pairs=list(c("pop1","pop2","contigs","scico::batlowW","d","darkgrey"), rep(NA,4))
  )
)

# map variable names to display names
value_map <- c(
  fst = "Mean F<sub>st</sub>",
  fst_sd = "F<sub>st</sub> (SD)",
  fst_se = "F<sub>st</sub> (SEM)",
  snps = "SNPs",
  cov = "Mean coverage",
  cov_sd = "Coverage (SD)",
  cov_se = "Coverage (SEM)",
  snps_per_contig = "SNPs per contig",
  contigs = "Contigs"
)

# generate a colorscale that plotly will understand from a named palette in paletteer
# increase n to increase the "smoothness" of the color scale
# na is the "missing" color, min is the dummy range used for the missing color
cscale <- function(pal,n=10,na="darkgrey",min=0.00001) {
  s <- paletteer_c(pal,n+1) %>%
    imap(\(col,i) {
      list((i-1)/n,col)
    })
  if (!is.na(na)) {
    s[[1]][[1]] <- min
    c(list(list(0,na), list(min,na)),s)
  }
}

# replace "NA" (not NA) in a string vector
fix_na <- function(x,na="n/a") replace(x,which(x == "NA"),na)

# summarize dataset (as above) by method and pool comparison
pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # now we walk through our different display pairs
    var_pairs %>%
      walk(\(trace_vars) {
        # and show the tab header
        cat(str_glue("### {trace_vars$title}\n\n"))
        print(h5(HTML(trace_vars$description)))

        # create cutoff slider
        cutoff_sel <- div(
          class="coverage-slider",
          tagList(
            tags$label(
              id=str_glue("heatmap-cutoff-label-{method$method}-{trace_vars$name}"),
              `for`=str_glue("heatmap-cutoff-sel-{method$method}-{trace_vars$name}"),
              str_glue('Minimum coverage: {params$nf$report_min_coverage}')
            ),
            div(
              id=str_glue("heatmap-cutoff-sel-{method$method}-{trace_vars$name}")
            )
          )
        )
        print(cutoff_sel)

        # cutoff slider handler code (js)
        # note double curly braces because the whole thing is
        # wrapped in str_glue
        cutoff_script <- tags$script(HTML(str_glue(
        '
           $(function() {{
             $("#heatmap-cutoff-sel-{method$method}-{trace_vars$name}").labeledslider({{
               min: {params$nf$report_min_coverage},
               max: {params$nf$report_max_coverage},
               step: {params$nf$report_coverage_step},
               tickInterval: {params$nf$report_coverage_step},
               change: function (e, ui) {{
                 var fig = $("#heatmap-fig-{method$method}-{trace_vars$name}")[0];
                 var figdata = $(`#heatmap-json-{method$method}-{trace_vars$name}-${{ui.value}}`).text();
                 $("#heatmap-cutoff-label-{method$method}-{trace_vars$name}").text(`Minimum coverage: ${{ui.value}}`);
                 Plotly.react(fig,JSON.parse(figdata));
               }},
               slide: function (e, ui) {{
                 var fig = $("#heatmap-fig-{method$method}-{trace_vars$name}")[0];
                 var figdata = $(`#heatmap-json-{method$method}-{trace_vars$name}-${{ui.value}}`).text();
                 $("#heatmap-cutoff-label-{method$method}-{trace_vars$name}").text(`Minimum coverage: ${{ui.value}}`);
                 Plotly.react(fig,JSON.parse(figdata));
               }}
             }});

          }});
        '
        )))
        print(cutoff_script)

        print(h5(tags$small(HTML(
          "Note: Grey cells indicate missing data."
        ))))

        # now walk through coverage cutoff levels
        # and create figure and/or figure json for each one
        cutoffs %>%
          walk(\(cutoff) {
            # filter data by coverage cutoff
            # and summarize by pool comparison
            fst_data <- fst_data %>%
              filter(avg_min_cov >= cutoff) %>%
              group_by(pop1,pop2) %>%
              summarise(
                fst_sd = sd(fst,na.rm=TRUE),
                fst_se = fst_sd / sqrt(n()),
                cov = mean(avg_min_cov,na.rm=TRUE),
                cov_sd = sd(avg_min_cov,na.rm = TRUE),
                cov_se = cov_sd / sqrt(n()),
                snps = n_distinct(chrom,pos,na.rm=TRUE),
                contigs = n_distinct(chrom,na.rm = TRUE),
                snps_per_contig = snps / contigs,
                fst = mean(fst,na.rm=TRUE)
              ) %>%
              ungroup() %>%
              # retain the cutoff level in the data
              mutate(cutoff=cutoff)
            
            # get all pool names
            all_pops <- sort(union(unique(fst_data$pop1),unique(fst_data$pop2)))

            # create a tibble of all possible combinations (sorted)
            full_table <- all_pops %>%
              combn(2) %>%
              apply(MARGIN = 2,FUN=\(x) sort(x)) %>%
              t() %>%
              as_tibble() %>%
              rename(pop1=1,pop2=2)

            # convert pool names to factors with all possible levels
            # make sure pop2 has levels in reverse so the figure looks right
            # (i.e., a nice triangle)
            # we left join from the table of all combos so we have all combos, even
            # if some have missing data
            hmd <- full_table %>%
              left_join(fst_data,by=c("pop1","pop2")) %>%
              arrange(pop1,desc(pop2)) %>%
              mutate(
                pop1 = factor(pop1,levels=all_pops),
                pop2 = factor(pop2,levels=rev(all_pops))
              ) %>%
              mutate(
                # create columns for the tooltip text
                across(where(is.numeric),\(x) x,.names = "{.col}_val"),
                # replace misisng integers with -1
                across(where(is.integer) & !ends_with("_val"),\(x) replace_na(x,-1)),
                # replace missing floats with min(x)*1e-5
                across(where(is.double) & !ends_with("_val"),\(x) replace_na(x,min(x,na.rm = TRUE)*0.00001))
              ) %>%
              arrange(pop1,desc(pop2))

            # get the factor level that would be the top row of the plot
            top_level <- last(levels(hmd$pop2))

            # now we make a dummy table for just that top row
            top_row <- hmd %>%
              filter(pop1 == top_level) %>%
              # switch pop1 and pop2
              mutate(temp=pop1,pop1=pop2,pop2=temp) %>%
              # drop the temp column
              select(-temp) %>%
              # set all numeric values to NA
              mutate(across(-c(pop1,pop2),~NA))

            # bind dummy values to plot data
            # it seems to matter that we bind these
            # to the end, rather than the other way around
            hmd <- hmd %>%
              bind_rows(top_row)

            # create an empty plotly figure
            # don't show tooltips if there's no data
            fig <- hmd %>%
              plot_ly(hoverongaps=FALSE)

            # now we go through each figure pair
            # and reduce them to a single plotly figure
            # that c(1,2) is just to keep track of if we're on
            # the lower or upper triangle
            fig <- trace_vars$pairs %>%
              reduce2(c(1,2),\(f,v,i) {
                # if the element is valid
                if (!all(is.na(v))) {
                  # add a heatmap trace
                  f %>%
                    add_trace(
                      type = "heatmap",
                      x = ~.data[[v[1]]], # x variable
                      y = ~.data[[v[2]]], # y variable
                      z = ~.data[[v[3]]], # z (color) variable
                      # this is what gets shown in the tooltip
                      customdata = ~fix_na( sprintf( str_c("%",v[5]), .data[[ str_glue("{v[3]}_val") ]] ) ),
                      # zmin and zmax are trying to make it so the "missing" 
                      # color doesn't show up in the color scale legend
                      zmin = ~min(.data[[v[[3]]]],na.rm = TRUE)*0.00001,
                      zmax = ~max(.data[[v[3]]],na.rm = TRUE),
                      colorscale = cscale(v[4],n = 100,na = v[6]), # color palette, based on 100 gradations
                      # style the colorbar
                      colorbar = list(
                        # show the appropriate display name
                        title=list(text=value_map[v[3]]),
                        # determine the position of the colorbar
                        # bottom if it's for the bottom triangle, top if it's for the top
                        y = ifelse(i == 1,0,1),
                        # which side of the colorbar we reckon the y-anchor from
                        yanchor = ifelse(i == 1,"bottom","top"),
                        len = 0.5,
                        lenmode = "fraction"
                      ),
                      # text template
                      text = ~str_glue("{pop1} - {pop2}"),
                      # hover text template (hide the trace name with <extra></extra>)
                      hovertemplate=str_glue("%{{text}}<br>{value_map[v[3]]}: %{{customdata}}<extra></extra>")
                    )
                } else return(f)
              },.init = fig) %>%
              layout(
                # name the figure axes and don't let the user zoom around
                xaxis = list(title = "Pool 1", fixedrange = TRUE),
                yaxis = list(title = "Pool 2", fixedrange = TRUE)
              ) %>%
              # hide the mode bar
              config(displayModeBar = FALSE)

            # assign id attribute to plotly div
            fig_id <- str_glue("heatmap-fig-{method$method}-{trace_vars$name}")
            fig$elementId <- fig_id

            if (cutoff == first(cutoffs)) {
              # output the figure to the report, but only if it's the first coverage cutoff
              print(tagList(fig))
            }

            # get minified figure json
            fig_json <- fig %>%
              plotly_json(jsonedit = FALSE) %>%
              jsonlite::minify()

            # create and print script tag with figure data json
            # we use this to draw the other cutoff level figures when the slider is dragged
            script_tag <- tags$script(
              id = str_glue("heatmap-json-{method$method}-{trace_vars$name}-{cutoff}"),
              type = 'application/json',
              HTML(fig_json)
            )
            print(script_tag)
          })

      })
  })
```

```{r, fst-correlation, results='asis', eval=show_fst}
cat("# F<sub>st</sub> method correlations {.tabset}\n\n")

# get calculation methods
methods <- unique(pool_data$method)
# split the dataset into subsets by calculation method
splot <- pool_data %>%
  split(.$method)
methods %>%
  combn(2) %>%
  array_branch(2) %>%
  walk(\(pair) {
    cat(str_glue("## F<sub>st</sub> correlation: {pair[1]} vs {pair[2]}\n\n"))
    print(h5(tags$small(HTML("Note: Due to potentially large datasets, only a subsample of 1,000 F<sub>st</sub> values is shown here."))))

    # make a joined table with both methods and subsample to 1000 rows
    corr <- splot[[pair[1]]] %>%
      sample_n(1000) %>%
      inner_join(splot[[pair[2]]],by=c("chrom","pos","pop1","pop2"))

    # do a linear regression
    lmm <- lm(fst.y ~ fst.x, data=corr)
    
    # get predicted data for the trend line
    corr <- corr %>%
      mutate(
        predicted = lmm %>%
          predict(corr %>% select(fst.x))
      ) 

    # get method names
    xtitle <- pair[1]
    ytitle <- pair[2]

    # plot the figure
    fig <- corr %>%
      plot_ly() %>%
      # add 1:1 line
      add_trace(
        x = ~fst.x,
        y = ~fst.x,
        type = 'scatter',
        mode = 'lines',
        line = list(color = '#232323', width = 0.7)
      ) %>%
      # add scatter 
      add_trace(
        x = ~fst.x,
        y = ~fst.y,
        type = 'scatter',
        mode = 'markers',
        marker = list(color = 'black')
      ) %>%
      # add trend line
      add_trace(
        x = ~fst.x,
        y = ~predicted,
        type = 'scatter',
        mode = 'lines',
        line = list(color = 'lightskyblue', dash="dash", width = 0.7)
      ) %>%
      layout(
        # label axes
        xaxis = list(title = str_glue("F<sub>st</sub> ({xtitle})")),
        yaxis = list(title = str_glue("F<sub>st</sub> ({ytitle})"))
      ) %>%
      # disappear the legends
      hide_guides()

    print(tagList(fig))
  })
```

```{r, fisher, results='asis', eval=show_fisher}
cat("# Fisher test plots {.tabset}\n\n")
print(h5(tags$small(
  "Fisher test results are presented as static plots due to the potentially large size of the datasets."
)))

fisher_data %>%
  group_by(method) %>%
  group_walk(\(fishr,method) {
    cat(str_glue("## {method$method}\n\n"))
    
    # make slider for coverage cutoff
    cutoff_slider <- div(
      class="coverage-slider",
      tagList(
        tags$label(
          id=str_glue("fisher-cutoff-label-{method$method}"),
          `for`=str_glue("fisher-cutoff-sel-{method$method}"),
          str_glue('Minimum coverage: {params$nf$report_min_coverage}')
        ),
        div(
          id=str_glue("fisher-cutoff-sel-{method$method}")
        )
      )
    )
    print(cutoff_slider)
    
    cutoff_script <- tags$script(HTML(str_glue(
    '
      $(function() {{
        $("#fisher-cutoff-sel-{method$method}").labeledslider({{
          min: {params$nf$report_min_coverage},
          max: {params$nf$report_max_coverage},
          step: {params$nf$report_coverage_step},
          tickInterval: {params$nf$report_coverage_step},
          change: function (e, ui) {{
            $(".fisher-plotz-{method$method}").hide();
            $(`#fisher-plot-{method$method}-${{ui.value}}`).show(); 
            $("#fisher-cutoff-label-{method$method}").text(`Minimum coverage: ${{ui.value}}`);
          }},
          slide: function (e, ui) {{
            $(".fisher-plotz-{method$method}").hide();
            $(`#fisher-plot-{method$method}-${{ui.value}}`).show(); 
            $("#fisher-cutoff-label-{method$method}").text(`Minimum coverage: ${{ui.value}}`);
          }}
        }});
     }});
    '
    )))
    print(cutoff_script)
    
    print(h6(HTML("Points above red line indicate <em>p</em> &lt; 0.05.")))
    
    figs <- cutoffs %>%
      # set_names() %>%
      map(\(cov) {
        # cat(str_glue("### Coverage ≥{cov}\n\n"))
        fig <- fishr %>%
          # filter by average minimum coverage
          filter(avg_min_cov >= cov) %>%
          # retain the cutoff level in the data
          # mutate(cutoff=cov)  %>%
          group_by(chrom,pos) %>%
          summarise( log_fisher = mean(log_fisher) ) %>%
          ungroup() %>%
          arrange(chrom,pos) %>%
          mutate(snp = row_number()) %>%
          ggplot() +
          geom_point(aes(x=snp,y=log_fisher),size=1) +
          geom_hline(yintercept = -log10(0.05), color="red") +
          theme_bw() +
          labs(x = 'SNP', y=expression(paste(-log[10]~"(p-value)")))
        
          disp <- if(cov == first(cutoffs)) "" else "display: none"
          plotTag(
            fig,
            alt=str_glue("Fisher's exast test p-values for coverage ≥{cov}"),
            width = 672,
            attribs = list(
              id = str_glue("fisher-plot-{method$method}-{cov}"),
              class = str_glue('fisher-plotz-{method$method}'),
              style = disp    
            )
          )
      })
    print(div(
      id='fisher-container',
      tagList( figs )
    ))
  })
```
