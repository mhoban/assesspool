---
title: assessPool analysis
output:
  html_document:
    toc: true               # table of contents
    toc_float: true         # float the table of contents to the left of the main document content
    toc_depth: 4            # header levels 1,2,3
    theme: default
    number_sections: false  # add section numbering to headers
    df_print: paged         # tables are printed as an html table with support for pagination over rows and columns
    highlight: pygments
    pdf_document: true
  pdf_document:
    toc: yes
date: "`r Sys.Date()`"
params:
  debug: FALSE
  fst_file: NULL
  fisher: NULL
  tz: NULL
  viz_filter: FALSE
  min_cov: 10
  max_cov: 70
  cov_step: 10
---
```{r setup, echo=FALSE, include=FALSE}
# when  run in a container, there are
# weird issues with the timezone and lubridate
# may spit out some errors. setting this fixes that
if (!is.null(params$tz)) {
  Sys.setenv(TZ=params$tz)
}

# load libraries
library(knitr)
library(yaml)
library(plotly)
library(DT)
library(readr)
library(dplyr)
library(stringr)
library(purrr)
library(paletteer)

if (params$debug) {
  options(show.error.locations = TRUE)
}

# set some global options
knitr::opts_chunk$set(echo = FALSE)
options(dplyr.summarise.inform = FALSE)
```

```{r init, include=FALSE}
# Load the datatables js
datatable(NULL)

# load the plotly js
plot_ly()

# plotly horizontal line
hline <- function(y = 0, color = "black") {
  list(
    type = "line",
    x0 = 0,
    x1 = 1,
    xref = "paper",
    y0 = y,
    y1 = y,
    line = list(color = color)
  )
}

# geometric mean function
gm_mean = function(x, na.rm=TRUE, zero.propagate = FALSE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(zero.propagate){
    if(any(x == 0, na.rm = TRUE)){
      return(0)
    }
    exp(mean(log(x), na.rm = na.rm))
  } else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
  }
}

# get a sequence of coverage cutoffs from input parameters
cutoffs <- seq(params$min_cov,params$max_cov,params$cov_step)

# load pool data
# start with fst
pool_data <- read_tsv(params$fst_file)

fisher_data <- NULL

# load fisher data if applicable
show_fisher <- !is.null(params$fisher)
if (show_fisher) {
  fisher_data <- read_tsv(params$fisher) %>%
    select(chrom,pos,pop1,pop2,avg_min_cov,log_fisher=fisher,method)
}
```

<!-- this section only gets processed if params$debug is TRUE -->
```{r, results='asis',  eval=params$debug}
cat("# Debug info\n")
```

```{r, eval=params$debug}
if (params$debug) {
  # print(params$meta$pools)
  cat("params\n\n")
  str(params)
}
```
<!-- end debug section -->

# Abstract

This report summarizes the output of population genetic analyses of a pool-seq RAD library.

# Data

This section provides a summary of sample/pool metadata.

```{r, results='asis', eval=params$viz_filter}
cat("# VCF Filtering\n")
```
<!--
  TODO: Show the filtering visualizations.
  This'll require a new nextflow process that does stepwise filtering to show what's lost at each step.
  idea: maybe rather than doing it linearly, allow the user to check boxes to decide which filtering
  steps to include, so that they can see cumulative effects for any combination rather than just
  one after the next
-->

# Pairwise F<sub>st</sub> by minimum coverage {.tabset}

```{r fst-cov-all, results='asis'}
# used for tab selection
all_pools <- c('All SNPs'=FALSE,'Shared loci (all pools)'=TRUE)

# walk through calculation methods
pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # walk through all_shared elements
    # (whether or not we're looking only at snps shared across all pools)
    all_pools %>%
      iwalk(\(all_shared,hdr) {
        # output tab header
        cat(str_glue("### {hdr}\n\n"))

        # filter data for all pools if necessary
        if (all_shared) {
          # get all unique pool names
          all_pools <- sort(
            union(
              unique(fst_data$pop1),
              unique(fst_data$pop2)
            )
          )

          # group data by snp (chrom/pos) and retain
          # snps where all populations are represented in comparisons
          # (either side)
          fst_data <- fst_data %>%
            group_by(chrom,pos) %>%
            filter(all(all_pools %in% unique(c(unique(pop1),unique(pop2))))) %>%
            ungroup()
        }

        # repeatedly filter the dataset for different coverage levels
        # and bind those together into a new dataset


        # now filter the main dataset for each cutoff level
        fst_cov <- cutoffs %>%
          map(\(cov) {
            fst_data %>%
              # filter by average minimum coverage
              filter(avg_min_cov >= cov) %>%
              # retain the cutoff level in the data
              mutate(cutoff=cov)
          }) %>%
          # and bind resulting subsets together into a superset
          list_rbind()

        # summarize the data by comparison and cutoff level
        fst_grp <- fst_cov %>%
          group_by(pop1,pop2,cutoff) %>%
          summarise(
            fst_sd = sd(fst),                 # std. dev. of fst
            fst = mean(fst),                  # mean fst
            fst_se = fst_sd / sqrt(n()),      # std. err. of fst
            cov = mean(avg_min_cov),          # mean coverage
            snps = n(),                       # snp count
            contigs = n_distinct(chrom),      # contig count
            snps_per_contig = snps / contigs  # mean snps per contig
          ) %>%
          # create a text representation of the comparison
          mutate(pair = str_glue("{pop1} - {pop2}")) %>%
          # sort by cutoff and comparison
          arrange(cutoff,pair) %>%
          ungroup()

        # plog the figure
        fig <- fst_grp %>%
          plot_ly(
            x = ~ fst,
            y = ~ pair,
            color = ~snps,
            frame = ~str_glue("≥{cutoff}"),
            # hover text templates
            text = ~str_c(snps," SNPs<br>",contigs," contigs"),
            hovertemplate = "F<sub>st</sub> (%{y}): %{x}<br>%{text}",
            type = 'scatter',
            mode = 'markers',
            marker = list(size = 12)
          ) %>%
          colorbar(title = "SNPs") %>%
          layout(
            margin=list(l = 100, r = 20, b = 10, t = 30),
            yaxis = list(title="Comparison",tickangle=-35,tickfont=list(size=12)),
            xaxis = list(title="F<sub>st</sub>",tickfont=list(size=12)),
            title = list(text=str_glue("F<sub>st</sub> ({method$method}) - {hdr}"), y=0.95)
          ) %>%
          # customize slider and remove play button
          animation_slider(currentvalue = list(prefix = "Minimum coverage: ", font = list(color = "black"))) %>%
          animation_button(visible = FALSE)

        # output the figure to html
        print(htmltools::tagList(fig))
      })
  })

```

# F<sub>st</sub> method correlations {.tabset}

# Summary heatmaps {.tabset}

```{r, heatmap-setup, results='asis'}

# a list of parameters we'll use to plot each figure
# each item consists of: display name, bottom-left heatmap, and (optionally) top-right heatmap
# individual heatmap options are: x value, y value, variable name, and color palette (from paletteer_c)
var_pairs <- list(
  list("F<sub>st</sub> (±SD)",c("pop1","pop2","fst","viridis::mako",".3f"), c("pop2","pop1","fst_sd","viridis::inferno",".2f")),
  list("SNPs / SNPs per contig",c("pop1","pop2","snps","scico::tokyo",",d"), c("pop2","pop1","snps_per_contig","viridis::rocket",".2f")),
  list("Mean coverage (±SD)",c("pop1","pop2","cov","viridis::cividis",".2f"), c("pop2","pop1","cov_sd","viridis::plasma",".2f")),
  list("Contigs",c("pop1","pop2","contigs","scico::batlowW",",d"), rep(NA,4))
)

# map variable names to display names
value_map <- c(
  fst = "Mean F<sub>st</sub>",
  fst_sd = "F<sub>st</sub> (SD)",
  fst_se = "F<sub>st</sub> (SEM)",
  snps = "SNPs",
  cov = "Mean coverage",
  cov_sd = "Coverage (SD)",
  cov_se = "Coverage (SEM)",
  snps_per_contig = "SNPs per contig",
  contigs = "Contigs"#,
  # fisher = "p-value (Fisher's exact test)"k,
  # log_fisher = "-log<sub>10</sub>(p-value) (Fisher's exact test)"
)

# shortcut to create a formula from a string
# ex: form("hello") creates ~hello as a formula
# this is so we can pass things to x and y in variables
form <- \(x) as.formula(str_glue("~{x}"))

# generate a colorscale that plotly will understand from a named palette in paletteer
# increase n to increase the "smoothness" of the color scale
cscale <- function(pal,n=10) {
  paletteer_c(pal,n+1) %>%
    imap(\(col,i) {
      list((i-1)/n,col)
    })
}

# background colors we might not use
bg_cols <- c('#0b1211', "#0b1211")

# summarize dataset (as above) by method and pool comparison
pool_data %>%
  group_by(method,pop1,pop2) %>%
  summarise(
    fst_sd = sd(fst),
    fst_se = fst_sd / sqrt(n()),
    cov = mean(avg_min_cov),
    cov_sd = sd(avg_min_cov),
    cov_se = cov_sd / sqrt(n()),
    snps = n(),
    contigs = n_distinct(chrom),
    snps_per_contig = snps / contigs,
    t_p = t.test(fst,mu=0,alternative = "greater")$p.value,
    fst = mean(fst)#,
    # fisher_sd = sd(fisher)
    # I don't think these belong here
    # log_fisher_sd = sd(log_fisher),
    # fisher_gm = gm_mean(fisher),
    # fisher = mean(fisher),
    # log_fisher = mean(log_fisher)
  ) %>%
  ungroup() %>%
  # walk through calculation methods
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # this is a little hack to get plotly to consider all heatmap cells
    # to be "active". basically, we add in NA entries for the comparisons that
    # don't exist. the upshot is that hovertext works for every cell

    # first, get all pool names
    all_pops <- sort(union(unique(fst_data$pop1),unique(fst_data$pop2)))

    # convert pool names to factors with all possible levels
    # make sure pop2 has levels in reverse so the figure looks right
    # (i.e., a nice triangle)
    hmd <- fst_data %>%
      arrange(pop1,desc(pop2)) %>%
      mutate(
        pop1 = factor(pop1,levels=all_pops),
        pop2 = factor(pop2,levels=rev(all_pops))
      )

    # get the factor level that would be the top row of the plot
    top_level <- last(levels(hmd$pop2))

    # now we get everything for pop1 (x) == top_level
    top_row <- hmd %>%
      filter(pop1 == top_level) %>%
      # switch pop1 and pop2
      mutate(temp=pop1,pop1=pop2,pop2=temp) %>%
      # drop the temp column
      select(-temp) %>%
      # set all numeric values to NA
      mutate(across(where(is.numeric),~NA))

    # bind dummy values to plot data
    # it seems to matter that we bind these
    # to the end, rather than the other way around
    hmd <- hmd %>%
      bind_rows(top_row)

    # now we walk through our different display pairs
    var_pairs %>%
      walk(\(trace_vars) {

        # pull out the header text
        hdr <- trace_vars[[1]]
        # and show the tab header
        cat(str_glue("### {hdr}\n\n"))

        # create an empty plotly figure
        fig <- hmd %>%
          plot_ly(hoverongaps=FALSE)

        # now we exclude the first element of trace_vars
        # and reduce the rest to a single plotly figure
        # that c(1,2) is just to keep track of if we're on
        # the first or second half
        fig <- trace_vars[-1] %>%
          reduce2(c(1,2),\(f,v,i) {
            # if the element is valid
            if (!all(is.na(v))) {
              # add a heatmap trace
              f %>%
                add_trace(
                  type = "heatmap",
                  x = form(v[1]), # x variable
                  y = form(v[2]), # y variable
                  z = form(v[3]), # z (color) variable
                  colorscale = cscale(v[4],n = 100), # color palette, based on 100 gradations
                  # style the colorbar
                  colorbar = list(
                    # show the appropriate display name
                    title=list(text=value_map[v[3]]),
                    # determine the position of the colorbar
                    # bottom if it's the first one, top if it's the second
                    y = ifelse(i == 1,0,1),
                    # which side of the colorbar we reckon the y-anchor from
                    yanchor = ifelse(i == 1,"bottom","top"),
                    len = 0.5,
                    lenmode = "fraction"
                  ),
                  # text template
                  text = ~str_glue("{pop1} - {pop2}"),
                  # hover text template (hide the trace name with <extra></extra>)
                  hovertemplate=str_glue("%{{text}}<br>{value_map[v[3]]}: %{{z:{v[5]}}}<extra></extra>")
                )
            } else return(f)
          },.init = fig) %>%
          # name the figure
          layout(
            xaxis = list(title = "Pool 1"),
            yaxis = list(title = "Pool 2")
          )
        # print the figure as html
        print(htmltools::tagList(fig))
      })
  })
```

```{r, fisher, results='asis', eval=show_fisher}
cat("# Fisher test plots {.tabset}\n\n")

fisher_data %>%
  group_by(method) %>%
  group_walk(\(fishr,method) {
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))
    fisher_cov <- cutoffs %>%
      set_names() %>%
      map(\(cov) {
        fishr %>%
          # filter by average minimum coverage
          filter(avg_min_cov >= cov) %>%
          # retain the cutoff level in the data
          # mutate(cutoff=cov)  %>%
          group_by(chrom,pos) %>%
          summarise( log_fisher = mean(log_fisher) ) %>%
          ungroup() %>%
          arrange(chrom,pos) %>%
          mutate(snp = row_number())
      })

      fisher_cov %>%
        iwalk(\(fish,cov) {
          cat(str_glue("### Coverage ≥{cov}\n\n"))
          fig <- ggplot(fish) +
            geom_point(aes(x=snp,y=log_fisher),size=1) +
            geom_hline(yintercept = -log10(0.05), color="red") +
            theme_bw() +
            labs(x = 'SNP', y=expression(paste(x[i])))
          print(fig)
          cat("\n\n")
        })
  })
```
