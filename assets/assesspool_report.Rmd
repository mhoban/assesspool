---
title: assessPool analysis
output:
  html_document:
    toc: true               # table of contents
    toc_float: true         # float the table of contents to the left of the main document content
    toc_depth: 4            # header levels 1,2,3
    theme: default
    number_sections: false  # add section numbering to headers
    df_print: paged         # tables are printed as an html table with support for pagination over rows and columns
    highlight: pygments
    pdf_document: true
  pdf_document:
    toc: yes
date: "`r Sys.Date()`"
params:
  debug: false
  project: null
  filter: null
  fst_file: null
  fisher: null
  tz: null
  viz_filter: true
  min_cov: 10
  max_cov: 70
  cov_step: 10
---
```{r setup, echo=FALSE, include=FALSE}
# when  run in a container, there are
# weird issues with the timezone and lubridate
# may spit out some errors. setting this fixes that
if (!is.null(params$tz)) {
  Sys.setenv(TZ=params$tz)
}

# load libraries
library(knitr)
library(yaml)
library(plotly)
library(DT)
library(readr)
library(dplyr)
library(stringr)
library(purrr)
library(paletteer)
library(fs)

if (params$debug) {
  options(show.error.locations = TRUE)
}

# set some global options
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
options(dplyr.summarise.inform = FALSE)
```

```{r init, include=FALSE}
# Load the datatables js
datatable(
  matrix(), extensions="Buttons"
)

# load the plotly js
plot_ly()

# plotly horizontal line
hline <- function(y = 0, color = "black") {
  list(
    type = "line",
    x0 = 0,
    x1 = 1,
    xref = "paper",
    y0 = y,
    y1 = y,
    line = list(color = color)
  )
}

# geometric mean function
gm_mean = function(x, na.rm=TRUE, zero.propagate = FALSE){
  if(any(x < 0, na.rm = TRUE)){
    return(NaN)
  }
  if(zero.propagate){
    if(any(x == 0, na.rm = TRUE)){
      return(0)
    }
    exp(mean(log(x), na.rm = na.rm))
  } else {
    exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
  }
}

# get a sequence of coverage cutoffs from input parameters
cutoffs <- seq(params$min_cov,params$max_cov,params$cov_step)

# load pool data
# start with fst
show_fst <- !is.null(params$fst_file)
if (show_fst) {
  pool_data <- read_tsv(params$fst_file)
} else {
  pool_data <- FALSE
}

fisher_data <- NULL

# load fisher data if applicable
show_fisher <- !is.null(params$fisher)
if (show_fisher) {
  fisher_data <- read_tsv(params$fisher) %>%
    select(chrom,pos,pop1,pop2,avg_min_cov,log_fisher=fisher,method)
}

# whether to show VCF filtering
show_filter <- params$viz_filter & !is.null(params$filter)
if (show_filter) {
  filters <- read_tsv(params$filter)
} else {
  filters <- NULL
}

# used for tab selection
all_pools <- c('All SNPs'=FALSE,'Shared loci (all pools)'=TRUE)

# place where stuff gets saved
data_dir <- "artifacts"

# create artifacts dir
# if it already exists nobody will care
dir_create(data_dir)

# move fst file into artifacts dir
# file_move(params$fst_file,data_dir)
```

<!-- this section only gets processed if params$debug is TRUE -->
```{r, results='asis',  eval=params$debug}
cat("# Debug info\n")
```

```{r, eval=params$debug}
if (params$debug) {
  # print(params$meta$pools)
  cat("params\n\n")
  str(params)
}
```
<!-- end debug section -->

# Abstract

This report summarizes the output of population genetic analyses of a pool-seq RAD library.

```{r, results='asis', eval=show_filter}
cat("# Filtering\n")

cat("<h4>SNPs remaining after each filtering step.</h4>\n\n")
cat("<h5><small>Note: filtering results displayed are independent, not cumulative.</small></h5>\n\n")
filters <- filters %>%
  arrange(desc(count)) %>%
  mutate(
    filter = replace(filter,which(filter == "before"),"<b>Unfiltered</b>"),
    filter = forcats::fct_reorder(filter,-count),
    filter = forcats::fct_relevel(filter,"<b>Unfiltered</b>"),
    filtered = count[filter == "<b>Unfiltered</b>"] - count,
    filtered = case_when(
      filter == "<b>Unfiltered</b>" ~ count,
      .default = filtered
    ),
    changed = filtered > 0
  ) #%>%
  # filter(filtered > 0)

changed <- filters %>%
  filter(changed)
unchanged <- filters %>%
  filter(!changed) %>%
  pull(filter) %>%
  as.character()

unchanged <- str_glue("<b>{unchanged}</b>")
unchanged <- str_c(unchanged,collapse=", ")
cat(str_glue("<h5><small>Filter options with no effect: {unchanged}.</small></h5>\n\n"))

font <- list(
  family = "Courier New",
  size = 14#,
  # color = "grey97"
)
label <- list(
  # bgcolor = "#232F34",
  # bordercolor = "transparent",
  font = font
)

num <- scales::comma#scales::label_number(big.mark = ",")
t_fmt <- '<b>Before filtering: {num(count[filter == "<b>Unfiltered</b>"])} SNPs<br>After filtering:  {num(count)} SNPs</b>'
fig <- ggplot(changed) +
  geom_bar(aes(x=filter,y=count,fill=count,text=str_glue(t_fmt)),stat="identity") +
  scale_fill_paletteer_c("grDevices::Turku",direction = -1,name="SNPs remaining",labels=scales::comma) +
  scale_y_continuous(labels=scales::comma) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = -30, hjust=-0.1),
        axis.title.x = element_text(margin = margin(t = -20)),
        plot.title = element_text(hjust = 0.5),
        plot.margin = unit(c(0.2,0.2,0.2,0.2), "cm"))

fig <- fig %>%
  ggplotly(tooltip="text") %>%
  config(displayModeBar = FALSE) %>%
  layout(
    xaxis = list(title = "Filter option", fixedrange = TRUE),
    yaxis = list(title = "SNPs remaining", fixedrange = TRUE)
  )  %>%
  style(hoverlabel = label)

print(htmltools::tagList(fig))
```

```{r, summaries, results='asis', eval=show_fst}
cat("# High-level summaries {.tabset}\n\n")

summary_datasets <- pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # walk through all_shared elements
    # (whether or not we're looking only at snps shared across all pools)
    all_pools %>%
      iwalk(\(all_shared,hdr) {
        # output tab header
        cat(str_glue("### {hdr} {{.tabset}}\n\n"))

        # filter data for all pools if necessary
        if (all_shared) {
          # get all unique pool names
          all_pools <- sort(
            union(
              unique(fst_data$pop1),
              unique(fst_data$pop2)
            )
          )

          # group data by snp (chrom/pos) and retain
          # snps where all populations are represented in comparisons
          # (either side)
          fst_data <- fst_data %>%
            group_by(chrom,pos) %>%
            filter(all(all_pools %in% unique(c(unique(pop1),unique(pop2))))) %>%
            ungroup()
        }

        # repeatedly filter the dataset for different coverage levels
        # and bind those together into a new dataset
        fst_cov <- cutoffs %>%
          map(\(cov) {
            fst_data %>%
              # filter by average minimum coverage
              filter(avg_min_cov >= cov) %>%
              # retain the cutoff level in the data
              mutate(cutoff=cov)
          }) %>%
          # and bind resulting subsets together into a superset
          list_rbind()

        # summarize the data by comparison and cutoff level
        fst_grp <- fst_cov %>%
          group_by(cutoff) %>%
          summarise(
            fst_sd = sd(fst),                 # std. dev. of fst
            fst = mean(fst),                  # mean fst
            fst_se = fst_sd / sqrt(n()),      # std. err. of fst
            cov = mean(avg_min_cov),          # mean coverage
            snps = n(),                       # snp count
            contigs = n_distinct(chrom),      # contig count
            snps_per_contig = snps / contigs, # mean snps per contig
            ci_lower= fst - qt(0.975, n() -1) * fst_se,
            ci_upper= fst + qt(0.975, n() -1) * fst_se
          ) %>%
          arrange(cutoff) %>%
          ungroup() %>%
          select(
            `Coverage cutoff`=cutoff,
            `Mean F<sub>st</sub>`=fst,
            `F<sub>st</sub> (SD)`=fst_sd,
            `F<sub>st</sub> (SEM)`=fst_se,
            `Mean coverage`=cov,
            SNPs=snps,
            Contigs=contigs,
            `SNPs per contig`=snps_per_contig,
            `CI (lower)`=ci_lower,
            `CI (upper)`=ci_upper
          )

        shared <- ifelse(all_shared,"all","shared")
        filename <- str_glue("{method$method}_{shared}_summary")

        js <- DT::JS(
          "function ( data, type, row, meta ) {",
          "return type === 'display' ?",
          "'<span class=\"num\" title=\"'+data+'\">'+(Math.round((data+Number.EPSILON)*1000)/1000).toLocaleString()+'</span>' :",
          "data;",
          "}"
        )

        # show plot table
        cat(str_glue("#### Plot\n\n"))

        cat("<h5>Global summary statistics by coverage cutoff</h5>\n\n")

        # create interactive plot and add traces
        fig <- fst_grp %>%
          plot_ly(
            y = ~ `Mean F<sub>st</sub>`,
            x = ~`Coverage cutoff`,
            name = "Mean F<sub>st</sub>",
            visible = T,
            mode = "lines+markers",
            type = "scatter"
          ) %>%
          add_trace(
            y = ~ `F<sub>st</sub> (SD)`,
            x = ~`Coverage cutoff`,
            name = "F<sub>st</sub> (SD)",
            visible = F,
            mode = "lines+markers",
            type = "scatter"
          ) %>%
          add_trace(
            y = ~SNPs,
            x = ~`Coverage cutoff`,
            name = "SNPs",
            mode = "lines+markers",
            type = "scatter",
            visible=F
          ) %>%
          add_trace(
            y = ~`SNPs per contig`,
            x = ~`Coverage cutoff`,
            name = "Mean SNPs per contig",
            visible = F,
            mode = "lines+markers",
            type = "scatter"
          ) %>%
          add_trace(
            y = ~Contigs,
            x = ~`Coverage cutoff`,
            name = "Contigs",
            visible = F,
            mode = "lines+markers",
            type = "scatter"
          )

        # configure button layout and behavior
        button_layout <- list(
          type = "buttons",
          direction = "right",
          xanchor = 'center',
          yanchor = "top",
          pad = list('r' = 0, 't' = 10, 'b' = 10),
          x = 0.5,
          y = 1.27,
          buttons = list(
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    T, F, F, F, F
                  )
                ),
                list(
                  yaxis = list(title = "Mean F<sub>st</sub>")
                )
              ),
              label = "F<sub>st</sub>"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, T, F, F, F
                  )
                ),
                list(yaxis = list(title = "F<sub>st</sub> (standard deviation)")
                )
              ),
              label = "F<sub>st</sub> (SD)"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, F, T, F, F
                  )
                ),
                list(yaxis = list(title = "SNPs")
                )
              ),
              label = "SNPs"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, F, F, T, F
                  )
                ),
                list(
                  yaxis = list(title = "Mean SNPs per contig")
                )
              ),
              label = "SNPs per contig"
            ),
            list(
              method = "update",
              args = list(
                list(
                  visible = list(
                    F, F, F, F, T
                  )
                ),
                list(
                  yaxis = list(title = "Number of contigs")
                )
              ),
              label = "Contigs"
            )
          )
        )

        # configure annotation properties
        annotation <- list(
          list(
            text = "Total",
            x = .1,
            y = 1.22,
            xref = 'paper',
            yref = 'paper',
            showarrow = FALSE
          )
        )

        # add layout and annotation to figure
        fig <- fig %>% layout(
          yaxis = list(title = "Mean F<sub>st</sub>",fixedrange=TRUE),
          xaxis = list(title = "Coverage cutoff",fixedrange=TRUE),
          title = list(text=str_glue("Summary statistics by coverage cutoff - {method$method}"), yref= 'paper', y=1),
          showlegend = F,
          updatemenus = list(button_layout),
          annotations = annotation
        ) %>%
          config(displayModeBar = FALSE)

        # display figure
        print(htmltools::tagList(fig))

        # show data table tab
        cat(str_glue("#### Table\n\n"))

        cat("<h5>Global summary statistics by coverage cutoff</h5>\n\n")

        # output the datatable
        print(
          htmltools::tagList(
            datatable(
              fst_grp,
              escape = FALSE,
              rownames = FALSE,
              filter = "none",
              autoHideNavigation = TRUE,
              extensions = 'Buttons',
              options = list(
                dom = 'tB',
                buttons = list(
                  list(
                    extend='csv',
                    title=filename,
                    exportOptions = list( modifier = list(page = "all"), orthogonal = "export"
                    )
                  )
                ),
                scrollX = TRUE,
                columnDefs = list(
                  list(
                    targets = c(2:5,8:10)-1,
                    render = js
                  )
                )
              )
            ) %>%
              formatRound(c(1,6,7),digits=0)
          )
        )
      })
  })
```



```{r fst-cov-all, results='asis', eval=show_fst}
cat("# Pairwise F<sub>st</sub> by minimum coverage {.tabset}\n\n")

# walk through calculation methods
pool_data %>%
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # walk through all_shared elements
    # (whether or not we're looking only at snps shared across all pools)
    all_pools %>%
      iwalk(\(all_shared,hdr) {
        # output tab header
        cat(str_glue("### {hdr} {{.tabset}}\n\n"))

        # filter data for all pools if necessary
        if (all_shared) {
          # get all unique pool names
          all_pools <- sort(
            union(
              unique(fst_data$pop1),
              unique(fst_data$pop2)
            )
          )

          # group data by snp (chrom/pos) and retain
          # snps where all populations are represented in comparisons
          # (either side)
          fst_data <- fst_data %>%
            group_by(chrom,pos) %>%
            filter(all(all_pools %in% unique(c(unique(pop1),unique(pop2))))) %>%
            ungroup()
        }

        # repeatedly filter the dataset for different coverage levels
        # and bind those together into a new dataset


        # now filter the main dataset for each cutoff level
        fst_cov <- cutoffs %>%
          map(\(cov) {
            fst_data %>%
              # filter by average minimum coverage
              filter(avg_min_cov >= cov) %>%
              # retain the cutoff level in the data
              mutate(cutoff=cov)
          }) %>%
          # and bind resulting subsets together into a superset
          list_rbind() %>%
          # create a text representation of the comparison
          mutate(pair = str_glue("{pop1} - {pop2}"))

        # summarize the data by comparison and cutoff level
        # precompute box plot stats because the datasets are too big
        # and pandoc runs out of memory
        fst_grp <- fst_cov %>%
          group_by(pop1,pop2,pair,cutoff) %>%
          summarise(
            fst_sd = sd(fst),                 # std. dev. of fst
            q1 = as.numeric(quantile(fst)[2]),
            q3 = as.numeric(quantile(fst)[4]),
            lwr = boxplot.stats(fst)$stats[1],
            upr = boxplot.stats(fst)$stats[5],
            med = median(fst),
            min = min(fst),
            max = max(fst),
            fst = mean(fst),                  # mean fst
            fst_se = fst_sd / sqrt(n()),      # std. err. of fst
            cov = mean(avg_min_cov),          # mean coverage
            snps = n(),                       # snp count
            contigs = n_distinct(chrom),      # contig count
            snps_per_contig = snps / contigs  # mean snps per contig
          ) %>%
          # sort by cutoff and comparison
          arrange(cutoff,pair) %>%
          ungroup()

        # plot scatter plot header
        cat("#### Scatter plot (means)\n\n")

        # plot the scatterplot
        fig <- fst_grp %>%
          plot_ly(
            x = ~ fst,
            y = ~ pair,
            color = ~snps,
            frame = ~str_glue("≥{cutoff}"),
            # hover text templates
            text = ~str_c(snps," SNPs<br>",contigs," contigs"),
            hovertemplate = "F<sub>st</sub> (%{y}): %{x}<br>%{text}",
            type = 'scatter',
            mode = 'markers',
            marker = list(size = 12)
          ) %>%
          colorbar(title = "SNPs") %>%
          layout(
            margin=list(l = 100, r = 20, b = 10, t = 30),
            yaxis = list(title="",tickangle=-35,tickfont=list(size=12)),
            xaxis = list(title="F<sub>st</sub>",tickfont=list(size=12)),
            title = list(text=str_glue("F<sub>st</sub> - {hdr}"), y=0.95)
          ) %>%
          # customize slider and remove play button
          animation_slider(currentvalue = list(prefix = "Minimum coverage: ", font = list(color = "black"))) %>%
          animation_button(visible = FALSE)

        # output the figure to html
        print(htmltools::tagList(fig))

        # print box plot header
        cat("#### Box plot (distributions)\n\n")

        # get outlier points
        outs <- fst_cov %>%
          group_by(pop1,pop2,pair,cutoff) %>%
          summarise(outs = boxplot.stats(fst)$out)  %>%
          ungroup()

        # generate boxplot figure
        fig <- fst_grp %>%
          plot_ly(
            type = "box",
            y = ~pair,
            q1 = ~q1,
            q3 = ~q3,
            median = ~med,
            frame = ~cutoff,
            lowerfence = ~lwr,
            upperfence = ~upr
          ) %>%
          add_trace(
            data = outs,
            inherit = FALSE,
            y = ~pair,
            x = ~outs,
            type="scatter",
            mode="markers",
            frame = ~cutoff
          ) %>%
          layout(showlegend = FALSE) %>%
          animation_slider(currentvalue = list(prefix = "Minimum coverage: ", font = list(color = "black"))) %>%
          animation_button(visible = FALSE) %>%
          layout(
            #margin=list(l = 200, r = 20, b = 80, t = 40),
            yaxis = list(tickangle=-35,tickfont=list(size=12),title=""),
            xaxis = list(tickfont=list(size=12),title="F<sub>st</sub>")
          )
        print(htmltools::tagList(fig))
      })
  })

```


```{r, fst-correlation, results='asis', eval=show_fst}
cat("# F<sub>st</sub> method correlations {.tabset}\n\n")

methods <- unique(pool_data$method)
# mc <- combn(methods,2)
splot <- pool_data %>%
  split(.$method)
methods %>%
  combn(2) %>%
  array_branch(2) %>%
  walk(\(pair) {
    cat(str_glue("## F<sub>st</sub> correlation: {pair[1]} vs {pair[2]}\n\n"))
    cat("<h5><small>Note: Due to potentially large datasets, these plots show only a subsample of 1,000 F<sub>st</sub> values.</small></h5>\n\n")

    corr <- splot[[pair[1]]] %>%
      inner_join(splot[[pair[2]]],by=c("chrom","pos","pop1","pop2"))

    lmm <- lm(fst.y ~ fst.x, data=corr)
    corr <- corr %>%
      mutate(
        predicted = lmm %>%
          predict(corr %>% select(fst.x))
      ) %>%
      sample_n(1000)

    xtitle <- unique(corr$method.x)
    ytitle <- unique(corr$method.y)

    fig <- corr %>%
      plot_ly() %>%
      add_trace(
        x = ~fst.x,
        y = ~fst.x,
        type = 'scatter',
        mode = 'lines',
        # mode = 'lines+markers'#,
        line = list(color = '#232323', width = 0.7)
      ) %>%
      add_trace(
        x = ~fst.x,
        y = ~fst.y,
        type = 'scatter',
        mode = 'markers',
        marker = list(color = 'black')
      ) %>%
      add_trace(
        x = ~fst.x,
        y = ~predicted,
        type = 'scatter',
        mode = 'lines',
        # mode = 'lines+markers'#,
        line = list(color = 'lightskyblue', dash="dash", width = 0.7)
      ) %>%
      layout(
        xaxis = list(title = str_glue("F<sub>st</sub> ({xtitle})")),
        yaxis = list(title = str_glue("F<sub>st</sub> ({ytitle})"))
      ) %>%
      hide_guides()

    print(htmltools::tagList(fig))
    # fig <- ggplot(corr,aes(x=fst.x,y=fst.y)) +
    #   geom_abline(slope=1,intercept=0,color="lightskyblue",linewidth=0.5,linetype="dashed") +
    #   geom_point() +
    #   geom_smooth(method="lm",se=FALSE,color="grey19",linewidth=0.5) +
    #   xlab(str_glue("F<sub>st</sub> ({xtitle})")) +
    #   ylab(str_glue("F<sub>st</sub> ({ytitle})"))
    # print(fig)
  })
```

```{r, heatmap-setup, results='asis', eval=show_fst}
cat("# Summary heatmaps {.tabset}\n\n")

# a list of parameters we'll use to plot each figure
# each item consists of: display name, bottom-left heatmap, and (optionally) top-right heatmap
# individual heatmap options are: x value, y value, variable name, and color palette (from paletteer_c)
var_pairs <- list(
  list(
    title="F<sub>st</sub> (±SD)",
    description="Lower triangle: mean pairwise F<sub>st</sub><br>Upper triangle: standard deviation of F<sub>st</sub>",
    pairs=list(c("pop1","pop2","fst","viridis::mako",".3f"), c("pop2","pop1","fst_sd","viridis::inferno",".2f"))
  ),
  list(
    title="SNPs / SNPs per contig",
    description="Lower triangle: pairwise shared SNPs contributing to F<sub>st</sub> calculation<br>Upper triangle: average shared SNPs per contig",
    pairs=list(c("pop1","pop2","snps","scico::tokyo",",d"), c("pop2","pop1","snps_per_contig","viridis::rocket",".2f"))
  ),
  list(
    title="Mean coverage (±SD)",
    description="Lower triangle: mean pairwise coverage<br>Upper triangle: pairwise coverage standard deviation",
    pairs=list(c("pop1","pop2","cov","viridis::cividis",".2f"), c("pop2","pop1","cov_sd","viridis::plasma",".2f"))
  ),
  list(
    title="Contigs",
    description="Pairwise shared contigs",
    pairs=list(c("pop1","pop2","contigs","scico::batlowW",",d"), rep(NA,4))
  )
)
# var_pairs <- list(
#   list("F<sub>st</sub> (±SD)",c("pop1","pop2","fst","viridis::mako",".3f"), c("pop2","pop1","fst_sd","viridis::inferno",".2f")),
#   list("SNPs / SNPs per contig",c("pop1","pop2","snps","scico::tokyo",",d"), c("pop2","pop1","snps_per_contig","viridis::rocket",".2f")),
#   list("Mean coverage (±SD)",c("pop1","pop2","cov","viridis::cividis",".2f"), c("pop2","pop1","cov_sd","viridis::plasma",".2f")),
#   list("Contigs",c("pop1","pop2","contigs","scico::batlowW",",d"), rep(NA,4))
# )

# map variable names to display names
value_map <- c(
  fst = "Mean F<sub>st</sub>",
  fst_sd = "F<sub>st</sub> (SD)",
  fst_se = "F<sub>st</sub> (SEM)",
  snps = "SNPs",
  cov = "Mean coverage",
  cov_sd = "Coverage (SD)",
  cov_se = "Coverage (SEM)",
  snps_per_contig = "SNPs per contig",
  contigs = "Contigs"#,
  # fisher = "p-value (Fisher's exact test)"k,
  # log_fisher = "-log<sub>10</sub>(p-value) (Fisher's exact test)"
)

# shortcut to create a formula from a string
# ex: form("hello") creates ~hello as a formula
# this is so we can pass things to x and y in variables
form <- \(x) as.formula(str_glue("~{x}"))

# generate a colorscale that plotly will understand from a named palette in paletteer
# increase n to increase the "smoothness" of the color scale
cscale <- function(pal,n=10) {
  paletteer_c(pal,n+1) %>%
    imap(\(col,i) {
      list((i-1)/n,col)
    })
}

# background colors we might not use
bg_cols <- c('#0b1211', "#0b1211")

# summarize dataset (as above) by method and pool comparison
pool_data %>%
  group_by(method,pop1,pop2) %>%
  summarise(
    fst_sd = sd(fst),
    fst_se = fst_sd / sqrt(n()),
    cov = mean(avg_min_cov),
    cov_sd = sd(avg_min_cov),
    cov_se = cov_sd / sqrt(n()),
    snps = n(),
    contigs = n_distinct(chrom),
    snps_per_contig = snps / contigs,
    t_p = t.test(fst,mu=0,alternative = "greater")$p.value,
    fst = mean(fst)#,
    # fisher_sd = sd(fisher)
    # I don't think these belong here
    # log_fisher_sd = sd(log_fisher),
    # fisher_gm = gm_mean(fisher),
    # fisher = mean(fisher),
    # log_fisher = mean(log_fisher)
  ) %>%
  ungroup() %>%
  # walk through calculation methods
  group_by(method) %>%
  group_walk(\(fst_data,method) {
    # output tab header
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))

    # this is a little hack to get plotly to consider all heatmap cells
    # to be "active". basically, we add in NA entries for the comparisons that
    # don't exist. the upshot is that hovertext works for every cell

    # first, get all pool names
    all_pops <- sort(union(unique(fst_data$pop1),unique(fst_data$pop2)))

    # convert pool names to factors with all possible levels
    # make sure pop2 has levels in reverse so the figure looks right
    # (i.e., a nice triangle)
    hmd <- fst_data %>%
      arrange(pop1,desc(pop2)) %>%
      mutate(
        pop1 = factor(pop1,levels=all_pops),
        pop2 = factor(pop2,levels=rev(all_pops))
      )

    # get the factor level that would be the top row of the plot
    top_level <- last(levels(hmd$pop2))

    # now we get everything for pop1 (x) == top_level
    top_row <- hmd %>%
      filter(pop1 == top_level) %>%
      # switch pop1 and pop2
      mutate(temp=pop1,pop1=pop2,pop2=temp) %>%
      # drop the temp column
      select(-temp) %>%
      # set all numeric values to NA
      mutate(across(where(is.numeric),~NA))

    # bind dummy values to plot data
    # it seems to matter that we bind these
    # to the end, rather than the other way around
    hmd <- hmd %>%
      bind_rows(top_row)

    # now we walk through our different display pairs
    var_pairs %>%
      walk(\(trace_vars) {

        # pull out the header text and description
        hdr <- trace_vars$title
        desc <- trace_vars$description
        # and show the tab header
        cat(str_glue("### {hdr}\n\n"))
        cat(str_glue("<h5>{desc}</h5>\n\n"))

        # create an empty plotly figure
        fig <- hmd %>%
          plot_ly(hoverongaps=FALSE)

        # now we exclude the first element of trace_vars
        # and reduce the rest to a single plotly figure
        # that c(1,2) is just to keep track of if we're on
        # the first or second half
        fig <- trace_vars$pairs %>%
          reduce2(c(1,2),\(f,v,i) {
            # if the element is valid
            if (!all(is.na(v))) {
              # add a heatmap trace
              f %>%
                add_trace(
                  type = "heatmap",
                  x = form(v[1]), # x variable
                  y = form(v[2]), # y variable
                  z = form(v[3]), # z (color) variable
                  colorscale = cscale(v[4],n = 100), # color palette, based on 100 gradations
                  # style the colorbar
                  colorbar = list(
                    # show the appropriate display name
                    title=list(text=value_map[v[3]]),
                    # determine the position of the colorbar
                    # bottom if it's the first one, top if it's the second
                    y = ifelse(i == 1,0,1),
                    # which side of the colorbar we reckon the y-anchor from
                    yanchor = ifelse(i == 1,"bottom","top"),
                    len = 0.5,
                    lenmode = "fraction"
                  ),
                  # text template
                  text = ~str_glue("{pop1} - {pop2}"),
                  # hover text template (hide the trace name with <extra></extra>)
                  hovertemplate=str_glue("%{{text}}<br>{value_map[v[3]]}: %{{z:{v[5]}}}<extra></extra>")
                )
            } else return(f)
          },.init = fig) %>%
          # name the figure
          layout(
            xaxis = list(title = "Pool 1", fixedrange = TRUE),
            yaxis = list(title = "Pool 2", fixedrange = TRUE)
          ) %>%
          # hide the mode bar
          config(displayModeBar = FALSE)
          # layout(xaxis = list(fixedrange = TRUE), yaxis = list(fixedrange = TRUE))

        # print the figure as html
        print(htmltools::tagList(fig))
      })
  })
```

```{r, fisher, results='asis', eval=show_fisher}
cat("# Fisher test plots {.tabset}\n\n")

fisher_data %>%
  group_by(method) %>%
  group_walk(\(fishr,method) {
    cat(str_glue("## {method$method} {{.tabset}}\n\n"))
    fisher_cov <- cutoffs %>%
      set_names() %>%
      map(\(cov) {
        fishr %>%
          # filter by average minimum coverage
          filter(avg_min_cov >= cov) %>%
          # retain the cutoff level in the data
          # mutate(cutoff=cov)  %>%
          group_by(chrom,pos) %>%
          summarise( log_fisher = mean(log_fisher) ) %>%
          ungroup() %>%
          arrange(chrom,pos) %>%
          mutate(snp = row_number())
      })

      fisher_cov %>%
        iwalk(\(fish,cov) {
          cat(str_glue("### Coverage ≥{cov}\n\n"))
          fig <- ggplot(fish) +
            geom_point(aes(x=snp,y=log_fisher),size=1) +
            geom_hline(yintercept = -log10(0.05), color="red") +
            theme_bw() +
            labs(x = 'SNP', y=expression(paste(x[i])))
          print(fig)
          cat("\n\n")
        })
  })
```
